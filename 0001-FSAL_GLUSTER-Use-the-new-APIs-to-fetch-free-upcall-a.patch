From bd73728619160dddea0acaf4772be9e47c0380f9 Mon Sep 17 00:00:00 2001
From: Soumya Koduri <skoduri@redhat.com>
Date: Tue, 18 Oct 2016 00:18:29 +0530
Subject: [PATCH 44/50] FSAL_GLUSTER: Use the new APIs to fetch & free upcall
 args

GlusterFS Upcall handling APIs have been remodelled to do
all the memory handling needed in gfapi and make the upcall
structure opaque so that in case if there are any changes
to it in future, it shall not break existing applications.

This change is to consume those APIs in FSAL_GLUSTER.

These changes are available in the libgfapi.so version >3.8.4
-https://bugzilla.redhat.com/show_bug.cgi?id=1347717.

Hence updated the library version needed as well.

Change-Id: Iad6c97a09aed801e7abd979cb452076bfef68b62
Signed-off-by: Soumya Koduri <skoduri@redhat.com>
---
 src/CMakeLists.txt              |  2 +-
 src/FSAL/FSAL_GLUSTER/fsal_up.c | 64 ++++++++++++++++++++++-------------------
 2 files changed, 35 insertions(+), 31 deletions(-)

diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 4ee4a43..b248fbd 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -517,7 +517,7 @@ if(USE_FSAL_GLUSTER)
   IF(GLUSTER_PREFIX)
     set(ENV{PKG_CONFIG_PATH} "${PKG_CONFIG_PATH}:${GLUSTER_PREFIX}/lib/pkgconfig")
   ENDIF(GLUSTER_PREFIX)
-  pkg_check_modules(GFAPI glusterfs-api>=7.3.8)
+  pkg_check_modules(GFAPI glusterfs-api>=7.3.8.4)
   if(NOT GFAPI_FOUND)
     if(STRICT_PACKAGE)
       message(FATAL_ERROR "STRICT PACKAGE: Cannot find GLUSTER GFAPI runtime. Disabling GLUSTER fsal build")
diff --git a/src/FSAL/FSAL_GLUSTER/fsal_up.c b/src/FSAL/FSAL_GLUSTER/fsal_up.c
index 070a8f5..4e5d610 100644
--- a/src/FSAL/FSAL_GLUSTER/fsal_up.c
+++ b/src/FSAL/FSAL_GLUSTER/fsal_up.c
@@ -96,21 +96,23 @@ int upcall_inode_invalidate(struct glusterfs_export *glfsexport,
 	}
 
 out:
-	glfs_h_close(object);
 	return rc;
 }
 
 void *GLUSTERFSAL_UP_Thread(void *Arg)
 {
-	struct glusterfs_export     *glfsexport                 = Arg;
+	struct glusterfs_export     *glfsexport         = Arg;
 	const struct fsal_up_vector *event_func;
 	char                        thr_name[16];
-	int                         rc                          = 0;
-	struct callback_arg         callback;
-	struct callback_inode_arg   *cbk_inode_arg              = NULL;
-	int                         reason                      = 0;
-	int                         retry                       = 0;
-	int                         errsv                       = 0;
+	int                         rc                  = 0;
+	struct glfs_upcall          *cbk                = NULL;
+	struct glfs_upcall_inode    *in_arg             = NULL;
+	enum glfs_upcall_reason     reason              = 0;
+	int                         retry               = 0;
+	int                         errsv               = 0;
+	struct glfs_object          *object             = NULL;
+	struct glfs_object          *p_object           = NULL;
+	struct glfs_object          *oldp_object        = NULL;
 
 
 	snprintf(thr_name, sizeof(thr_name),
@@ -138,8 +140,6 @@ void *GLUSTERFSAL_UP_Thread(void *Arg)
 		goto out;
 	}
 
-	callback.fs = glfsexport->gl_fs;
-
 	/* Start querying for events and processing. */
 	/** @todo : Do batch processing instead */
 	while (!atomic_fetch_int8_t(&glfsexport->destroy_mode)) {
@@ -147,11 +147,10 @@ void *GLUSTERFSAL_UP_Thread(void *Arg)
 			     "Requesting event from FSAL Callback interface for %p.",
 			     glfsexport->gl_fs);
 
-		callback.reason = 0;
+		reason = 0;
 
-		rc = glfs_h_poll_upcall(glfsexport->gl_fs, &callback);
+		rc = glfs_h_poll_upcall(glfsexport->gl_fs, &cbk);
 		errsv = errno;
-		reason = callback.reason;
 
 		if (rc != 0) {
 			/* if ENOMEM retry for couple of times
@@ -190,42 +189,47 @@ void *GLUSTERFSAL_UP_Thread(void *Arg)
 			     "Received upcall event: reason(%d)",
 			     reason);
 
+		if (!cbk) {
+			usleep(10);
+			continue;
+		}
+
+		reason = glfs_upcall_get_reason(cbk);
 		/* Decide what type of event this is
 		 * inode update / invalidate? */
 		switch (reason) {
-		case GFAPI_CBK_EVENT_NULL:
+		case GLFS_UPCALL_EVENT_NULL:
 			usleep(10);
 			continue;
-		case GFAPI_INODE_INVALIDATE:
-			cbk_inode_arg =
-				(struct callback_inode_arg *)callback.event_arg;
+		case GLFS_UPCALL_INODE_INVALIDATE:
+			in_arg = glfs_upcall_get_event(cbk);
 
-			if (!cbk_inode_arg) {
+			if (!in_arg) {
 				/* Could be ENOMEM issues. continue */
 				LogWarn(COMPONENT_FSAL_UP,
 					"Received NULL upcall event arg");
 				break;
 			}
 
-			if (cbk_inode_arg->object)
-				upcall_inode_invalidate(glfsexport,
-							cbk_inode_arg->object);
-			if (cbk_inode_arg->p_object)
-				upcall_inode_invalidate(glfsexport,
-						  cbk_inode_arg->p_object);
-			if (cbk_inode_arg->oldp_object)
+			object = glfs_upcall_inode_get_object(in_arg);
+			if (object)
+				upcall_inode_invalidate(glfsexport, object);
+			p_object = glfs_upcall_inode_get_pobject(in_arg);
+			if (p_object)
+				upcall_inode_invalidate(glfsexport, p_object);
+			oldp_object = glfs_upcall_inode_get_oldpobject(in_arg);
+			if (oldp_object)
 				upcall_inode_invalidate(glfsexport,
-						  cbk_inode_arg->oldp_object);
+							oldp_object);
 			break;
 		default:
 			LogWarn(COMPONENT_FSAL_UP, "Unknown event: %d", reason);
 			continue;
 		}
-		if (cbk_inode_arg) {
-			free(cbk_inode_arg);
-			cbk_inode_arg = NULL;
+		if (cbk) {
+			glfs_free(cbk);
+			cbk = NULL;
 		}
-		callback.event_arg = NULL;
 	}
 
 out:
-- 
2.5.0


