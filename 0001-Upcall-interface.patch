From 1cea9f7c19a24ce453f9c9cfce68013347333a0a Mon Sep 17 00:00:00 2001
From: Soumya Koduri <skoduri@redhat.com>
Date: Tue, 3 Feb 2015 14:46:41 +0530
Subject: [PATCH 12/20] FSAL_GLUSTER: Upcall interface to receive notifications from the server.

Defined a new thread which polls for upcall notifications from the
server and takes action accordingly.

At present the callback event handled in this interface is -
* GFAPI_INODE_INVALIDATION

Change-Id: I370d07cf43538f904b37350aa4ca1144c190f746
Signed-off-by: Soumya Koduri <skoduri@redhat.com>
---
 src/FSAL/FSAL_GLUSTER/CMakeLists.txt     |    1 +
 src/FSAL/FSAL_GLUSTER/export.c           |   35 +++++-
 src/FSAL/FSAL_GLUSTER/fsal_up.c          |  228 ++++++++++++++++++++++++++++++
 src/FSAL/FSAL_GLUSTER/gluster_internal.c |   73 ++++++++++
 src/FSAL/FSAL_GLUSTER/gluster_internal.h |    7 +
 5 files changed, 342 insertions(+), 2 deletions(-)
 create mode 100644 src/FSAL/FSAL_GLUSTER/fsal_up.c

diff --git a/src/FSAL/FSAL_GLUSTER/CMakeLists.txt b/src/FSAL/FSAL_GLUSTER/CMakeLists.txt
index d60fb2f..2c2d1ad 100644
--- a/src/FSAL/FSAL_GLUSTER/CMakeLists.txt
+++ b/src/FSAL/FSAL_GLUSTER/CMakeLists.txt
@@ -18,6 +18,7 @@ SET(fsalgluster_LIB_SRCS
    main.c
    export.c
    handle.c
+   fsal_up.c
    gluster_internal.h
    gluster_internal.c
    mds.c
diff --git a/src/FSAL/FSAL_GLUSTER/export.c b/src/FSAL/FSAL_GLUSTER/export.c
index 84a7f61..d8c3252 100644
--- a/src/FSAL/FSAL_GLUSTER/export.c
+++ b/src/FSAL/FSAL_GLUSTER/export.c
@@ -50,6 +50,8 @@ static void export_release(struct fsal_export *exp_hdl)
 {
 	struct glusterfs_export *glfs_export =
 	    container_of(exp_hdl, struct glusterfs_export, export);
+	int *retval = NULL;
+	int err     = 0;
 
 	/* check activity on the export */
 
@@ -58,6 +60,22 @@ static void export_release(struct fsal_export *exp_hdl)
 			   &glfs_export->export.exports);
 	free_export_ops(&glfs_export->export);
 
+	glfs_export->destroy_mode = true;
+
+	/* Wait for up_thread to exit */
+	err = pthread_join(glfs_export->up_thread, (void **)&retval);
+
+	if (*retval) {
+		LogDebug(COMPONENT_FSAL, "Up_thread join returned value %d",
+			 *retval);
+	}
+
+	if (err) {
+		LogCrit(COMPONENT_FSAL, "Up_thread join failed (%s)",
+			strerror(err));
+		return;
+	}
+
 	/* Gluster and memory cleanup */
 	glfs_fini(glfs_export->gl_fs);
 	glfs_export->gl_fs = NULL;
@@ -552,7 +570,7 @@ fsal_status_t glusterfs_create_export(struct fsal_module *fsal_hdl,
 				      struct config_error_type *err_type,
 				      const struct fsal_up_vector *up_ops)
 {
-	int rc;
+	int rc = 0;
 	fsal_status_t status = { ERR_FSAL_NO_ERROR, 0 };
 	struct glusterfs_export *glfsexport = NULL;
 	glfs_t *fs = NULL;
@@ -598,7 +616,6 @@ fsal_status_t glusterfs_create_export(struct fsal_module *fsal_hdl,
 	}
 
 	export_ops_init(&glfsexport->export.exp_ops);
-	glfsexport->export.up_ops = up_ops;
 
 	fs = glfs_new(params.glvolname);
 	if (!fs) {
@@ -653,6 +670,7 @@ fsal_status_t glusterfs_create_export(struct fsal_module *fsal_hdl,
 	glfsexport->acl_enable =
 		((op_ctx->export->export_perms.options &
 		  EXPORT_OPTION_DISABLE_ACL) ? 0 : 1);
+	glfsexport->destroy_mode = false;
 
 	op_ctx->fsal_export = &glfsexport->export;
 
@@ -695,6 +713,19 @@ fsal_status_t glusterfs_create_export(struct fsal_module *fsal_hdl,
 		fsal_ops_pnfs(&glfsexport->export.fsal->m_ops);
 	}
 
+	if (up_ops) {
+		glfsexport->export.up_ops = up_ops;
+		rc = initiate_up_thread(glfsexport);
+
+		if (rc != 0) {
+			LogCrit(COMPONENT_FSAL,
+				"Unable to create GLUSTERFSAL_UP_Thread. Export: %s",
+				op_ctx->export->fullpath);
+			status.major = ERR_FSAL_FAULT;
+			goto out;
+		}
+	}
+
  out:
 	if (params.glvolname)
 		gsh_free(params.glvolname);
diff --git a/src/FSAL/FSAL_GLUSTER/fsal_up.c b/src/FSAL/FSAL_GLUSTER/fsal_up.c
new file mode 100644
index 0000000..298ff9b
--- /dev/null
+++ b/src/FSAL/FSAL_GLUSTER/fsal_up.c
@@ -0,0 +1,228 @@
+/*
+ * Copyright (C) Red Hat  Inc., 2015
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 3 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.
+ *
+ * ---------------------------------------
+ */
+
+/**
+ * @file    fsal_up.c
+ *
+ * @author  Soumya Koduri <skoduri@redhat.com>
+ *
+ * @brief   Upcall Interface for FSAL_GLUSTER
+ *
+ */
+
+#include "config.h"
+
+#include "fsal.h"
+#include "fsal_up.h"
+#include "gluster_internal.h"
+#include "fsal_convert.h"
+#include <sys/types.h>
+#include <unistd.h>
+#include <utime.h>
+#include <sys/time.h>
+
+int upcall_inode_invalidate(struct glusterfs_export *glfsexport,
+			     struct glfs_object *object)
+{
+	int	     rc                             = -1;
+	glfs_t          *fs                         = NULL;
+	char            vol_uuid[GLAPI_UUID_LENGTH] = {'\0'};
+	uint32_t        upflags                     = 0;
+	unsigned char   globjhdl[GLAPI_HANDLE_LENGTH];
+	struct gsh_buffdesc         key;
+	const struct fsal_up_vector *event_func;
+
+	fs = glfsexport->gl_fs;
+	if (!fs) {
+		LogCrit(COMPONENT_FSAL_UP,
+			"Invalid fs object of the glfsexport(%p)",
+			 glfsexport);
+		goto out;
+	}
+
+	rc = glfs_h_extract_handle(object, globjhdl+GLAPI_UUID_LENGTH,
+				   GFAPI_HANDLE_LENGTH);
+	if (rc < 0) {
+		LogDebug(COMPONENT_FSAL_UP,
+			 "glfs_h_extract_handle failed %p",
+			 fs);
+		goto out;
+	}
+
+	rc = glfs_get_volumeid(fs, vol_uuid,
+			       GLAPI_UUID_LENGTH);
+	if (rc < 0) {
+		LogDebug(COMPONENT_FSAL_UP,
+			 "glfs_get_volumeid failed %p",
+			 fs);
+		goto out;
+	}
+
+	memcpy(globjhdl, vol_uuid, GLAPI_UUID_LENGTH);
+	key.addr = &globjhdl;
+	key.len = GLAPI_HANDLE_LENGTH;
+
+	LogDebug(COMPONENT_FSAL_UP, "Received event to process for %p",
+		 fs);
+
+	upflags = CACHE_INODE_INVALIDATE_ATTRS |
+		  CACHE_INODE_INVALIDATE_CONTENT;
+	event_func = glfsexport->export.up_ops;
+
+	rc = event_func->invalidate_close(
+					glfsexport->export.fsal,
+					event_func,
+					&key,
+					upflags);
+
+	if (rc && rc != CACHE_INODE_NOT_FOUND) {
+		LogWarn(COMPONENT_FSAL_UP,
+			"Inode_Invalidate event could not be processed for fd %p, rc %d",
+			glfsexport->gl_fs, rc);
+	}
+
+out:
+	glfs_h_close(object);
+	return rc;
+}
+
+void *GLUSTERFSAL_UP_Thread(void *Arg)
+{
+	struct glusterfs_export     *glfsexport                 = Arg;
+	const struct fsal_up_vector *event_func;
+	char                        thr_name[16];
+	int                         rc                          = 0;
+	struct callback_arg         callback;
+	struct callback_inode_arg   *cbk_inode_arg              = NULL;
+	int                         reason                      = 0;
+	int                         retry                       = 0;
+	int                         errsv                       = 0;
+
+
+	snprintf(thr_name, sizeof(thr_name),
+		 "fsal_up_%p",
+		 glfsexport->gl_fs);
+	SetNameFunction(thr_name);
+
+	/* Set the FSAL UP functions that will be used to process events. */
+	event_func = glfsexport->export.up_ops;
+
+	if (event_func == NULL) {
+		LogFatal(COMPONENT_FSAL_UP,
+			 "FSAL up vector does not exist. Can not continue.");
+		gsh_free(Arg);
+		return NULL;
+	}
+
+	LogFullDebug(COMPONENT_FSAL_UP,
+		     "Initializing FSAL Callback context for %p.",
+		     glfsexport->gl_fs);
+
+	if (!glfsexport->gl_fs) {
+		LogCrit(COMPONENT_FSAL_UP,
+			"FSAL Callback interface - Null glfs context.");
+		goto out;
+	}
+
+	callback.fs = glfsexport->gl_fs;
+
+	/* Start querying for events and processing. */
+	while (!glfsexport->destroy_mode) {
+		LogFullDebug(COMPONENT_FSAL_UP,
+			     "Requesting event from FSAL Callback interface for %p.",
+			     glfsexport->gl_fs);
+
+		callback.reason = 0;
+
+		rc = glfs_h_poll_upcall(glfsexport->gl_fs, &callback);
+		errsv = errno;
+		reason = callback.reason;
+
+		if (rc != 0) {
+			LogCrit(COMPONENT_FSAL_UP,
+				"Poll upcall failed for %p. rc %d errno %d (%s) reason %d",
+				glfsexport->gl_fs, rc, errsv,
+				strerror(errsv), reason);
+
+			rc = -(rc);
+			/* Could be ENOMEM issues. Retry for couple of times
+			 * and then exit
+			 */
+			if (retry < 10) {
+				sleep(1);
+				retry++;
+				continue;
+			} else {
+				LogFatal(COMPONENT_FSAL_UP,
+					 "Retry limit for poll_upcall exceeded for (%p).",
+					 glfsexport->gl_fs);
+				return NULL;
+			}
+		}
+
+		retry = 0;
+
+		LogFullDebug(COMPONENT_FSAL_UP,
+			     "Received upcall event: reason(%d)",
+			     reason);
+
+		if (!reason)
+			continue;
+
+
+		/* Decide what type of event this is
+		 * inode update / invalidate? */
+		switch (reason) {
+		case GFAPI_INODE_INVALIDATE:
+		{
+			cbk_inode_arg =
+				(struct callback_inode_arg *)callback.event_arg;
+
+			if (!cbk_inode_arg) {
+				/* Could be ENOMEM issues. continue */
+				LogWarn(COMPONENT_FSAL_UP,
+					"Received NULL upcall event arg");
+				break;
+			}
+
+			if (cbk_inode_arg->object)
+				upcall_inode_invalidate(glfsexport,
+							cbk_inode_arg->object);
+			if (cbk_inode_arg->p_object)
+				upcall_inode_invalidate(glfsexport,
+						  cbk_inode_arg->p_object);
+			if (cbk_inode_arg->oldp_object)
+				upcall_inode_invalidate(glfsexport,
+						  cbk_inode_arg->oldp_object);
+		}
+		break;
+		default:
+			LogWarn(COMPONENT_FSAL_UP, "Unknown event: %d", reason);
+			continue;
+		}
+		if (cbk_inode_arg) {
+			free(cbk_inode_arg);
+			cbk_inode_arg = NULL;
+		}
+		callback.event_arg = NULL;
+	}
+
+out:
+	return NULL;
+}				/* GLUSTERFSFSAL_UP_Thread */
diff --git a/src/FSAL/FSAL_GLUSTER/gluster_internal.c b/src/FSAL/FSAL_GLUSTER/gluster_internal.c
index b677467..ad12d2a 100644
--- a/src/FSAL/FSAL_GLUSTER/gluster_internal.c
+++ b/src/FSAL/FSAL_GLUSTER/gluster_internal.c
@@ -951,6 +951,79 @@ fsal_status_t glusterfs_process_acl(struct glfs *fs,
 	return status;
 }
 
+int initiate_up_thread(struct glusterfs_export *glfsexport)
+{
+
+	pthread_attr_t up_thr_attr;
+	int retval  = -1;
+	int err   = 0;
+	int retries = 10;
+
+	memset(&up_thr_attr, 0, sizeof(up_thr_attr));
+
+	/* Initialization of thread attributes from nfs_init.c */
+	err = pthread_attr_init(&up_thr_attr);
+	if (err) {
+		LogCrit(COMPONENT_THREAD,
+			"can't init pthread's attributes (%s)",
+			strerror(err));
+		goto out;
+	}
+
+	err = pthread_attr_setscope(&up_thr_attr,
+				      PTHREAD_SCOPE_SYSTEM);
+	if (err) {
+		LogCrit(COMPONENT_THREAD,
+			"can't set pthread's scope (%s)",
+			strerror(err));
+		goto out;
+	}
+
+	err = pthread_attr_setdetachstate(&up_thr_attr,
+					  PTHREAD_CREATE_JOINABLE);
+	if (err) {
+		LogCrit(COMPONENT_THREAD,
+			"can't set pthread's join state (%s)",
+			strerror(err));
+		goto out;
+	}
+
+	err = pthread_attr_setstacksize(&up_thr_attr, 2116488);
+	if (err) {
+		LogCrit(COMPONENT_THREAD,
+			"can't set pthread's stack size (%s)",
+			strerror(err));
+		goto out;
+	}
+
+	do {
+		err = pthread_create(&glfsexport->up_thread,
+					&up_thr_attr,
+					GLUSTERFSAL_UP_Thread,
+					glfsexport);
+		sleep(1);
+	} while (err && (err == EAGAIN) && (retries-- > 0));
+
+	if (err) {
+		LogCrit(COMPONENT_THREAD,
+			"can't create upcall pthread (%s)",
+			strerror(err));
+		goto out;
+	}
+
+	retval = 0;
+
+out:
+	err = pthread_attr_destroy(&up_thr_attr);
+	if (err) {
+		LogCrit(COMPONENT_THREAD,
+			"can't destroy pthread's attributes (%s)",
+			strerror(err));
+	}
+
+	return retval;
+}
+
 #ifdef GLTIMING
 void latency_update(struct timespec *s_time, struct timespec *e_time, int opnum)
 {
diff --git a/src/FSAL/FSAL_GLUSTER/gluster_internal.h b/src/FSAL/FSAL_GLUSTER/gluster_internal.h
index 2bfabd6..79ee788 100644
--- a/src/FSAL/FSAL_GLUSTER/gluster_internal.h
+++ b/src/FSAL/FSAL_GLUSTER/gluster_internal.h
@@ -352,6 +352,8 @@ struct glusterfs_export {
 	bool acl_enable;
 	bool pnfs_ds_enabled;
 	bool pnfs_mds_enabled;
+	bool destroy_mode;
+	pthread_t up_thread; /* upcall thread */
 };
 
 struct glusterfs_handle {
@@ -531,5 +533,10 @@ nfsstat4 getdeviceinfo(struct fsal_module *fsal_hdl,
 			XDR *da_addr_body, const layouttype4 type,
 			const struct pnfs_deviceid *deviceid);
 
+/* UP thread routines */
+void *GLUSTERFSAL_UP_Thread(void *Arg);
+int initiate_up_thread(struct glusterfs_export *glfsexport);
+int upcall_inode_invalidate(struct glusterfs_export *glfsexport,
+			    struct glfs_object *object);
 
 #endif				/* GLUSTER_INTERNAL */
-- 
1.7.1

