From 307a1627bf6ce66706567d1ec83685db411ddd98 Mon Sep 17 00:00:00 2001
From: Daniel Gryniewicz <dang@redhat.com>
Date: Mon, 19 Dec 2016 10:28:36 -0500
Subject: [PATCH] Always lock when invalidating dirents

mdcache_dirent_invalidate_all() requires the content lock on the
directory to be taken.  Ensure it's taken by all callers.

Change-Id: I0b8682fd989097c8daf152e885d83290e2594dfe
Signed-off-by: Daniel Gryniewicz <dang@redhat.com>
---
 src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_handle.c  | 17 ++++++++++++++++-
 src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_helpers.c |  5 +++--
 2 files changed, 19 insertions(+), 3 deletions(-)

diff --git a/src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_handle.c b/src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_handle.c
index bf59bf1..3bd4f89 100644
--- a/src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_handle.c
+++ b/src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_handle.c
@@ -595,7 +595,9 @@ static fsal_status_t mdcache_readdir(struct fsal_obj_handle *dir_hdl,
 				 * MDCACHE_BYPASS_DIRCACHE and pass through */
 				atomic_set_uint32_t_bits(&directory->mde_flags,
 						 MDCACHE_BYPASS_DIRCACHE);
+				PTHREAD_RWLOCK_wrlock(&directory->content_lock);
 				mdcache_dirent_invalidate_all(directory);
+				PTHREAD_RWLOCK_unlock(&directory->content_lock);
 				return mdcache_readdir_uncached(directory,
 								whence,
 								dir_state,
@@ -821,7 +823,9 @@ static fsal_status_t mdcache_rename(struct fsal_obj_handle *obj_hdl,
 			LogDebug(COMPONENT_CACHE_INODE,
 				 "remove entry failed with status %s",
 				 fsal_err_txt(status));
+			PTHREAD_RWLOCK_wrlock(&mdc_newdir->content_lock);
 			mdcache_dirent_invalidate_all(mdc_newdir);
+			PTHREAD_RWLOCK_unlock(&mdc_newdir->content_lock);
 		}
 
 		/* Mark unreachable */
@@ -842,7 +846,9 @@ static fsal_status_t mdcache_rename(struct fsal_obj_handle *obj_hdl,
 		if (FSAL_IS_ERROR(status)) {
 			/* We're obviously out of date.  Throw out the cached
 			   directory */
+			PTHREAD_RWLOCK_wrlock(&mdc_newdir->content_lock);
 			mdcache_dirent_invalidate_all(mdc_newdir);
+			PTHREAD_RWLOCK_unlock(&mdc_newdir->content_lock);
 		}
 	} else {
 		LogDebug(COMPONENT_CACHE_INODE,
@@ -857,7 +863,9 @@ static fsal_status_t mdcache_rename(struct fsal_obj_handle *obj_hdl,
 			LogDebug(COMPONENT_CACHE_INODE,
 				 "Remove stale dirent returned %s",
 				 fsal_err_txt(status));
+			PTHREAD_RWLOCK_wrlock(&mdc_newdir->content_lock);
 			mdcache_dirent_invalidate_all(mdc_newdir);
+			PTHREAD_RWLOCK_unlock(&mdc_newdir->content_lock);
 		}
 
 		status = mdcache_dirent_add(mdc_newdir, new_name, mdc_obj);
@@ -867,7 +875,9 @@ static fsal_status_t mdcache_rename(struct fsal_obj_handle *obj_hdl,
 			   directory */
 			LogCrit(COMPONENT_CACHE_INODE, "Add dirent returned %s",
 				fsal_err_txt(status));
+			PTHREAD_RWLOCK_wrlock(&mdc_newdir->content_lock);
 			mdcache_dirent_invalidate_all(mdc_newdir);
+			PTHREAD_RWLOCK_unlock(&mdc_newdir->content_lock);
 		}
 
 		/* Remove the old entry */
@@ -876,7 +886,9 @@ static fsal_status_t mdcache_rename(struct fsal_obj_handle *obj_hdl,
 			LogDebug(COMPONENT_CACHE_INODE,
 				 "Remove old dirent returned %s",
 				 fsal_err_txt(status));
+			PTHREAD_RWLOCK_wrlock(&mdc_olddir->content_lock);
 			mdcache_dirent_invalidate_all(mdc_olddir);
+			PTHREAD_RWLOCK_unlock(&mdc_olddir->content_lock);
 		}
 	}
 
@@ -1212,8 +1224,11 @@ static fsal_status_t mdcache_unlink(struct fsal_obj_handle *dir_hdl,
 		if (status.major == ERR_FSAL_STALE)
 			(void)mdcache_kill_entry(parent);
 		else if (status.major == ERR_FSAL_NOTEMPTY &&
-			 (obj_hdl->type == DIRECTORY))
+			 (obj_hdl->type == DIRECTORY)) {
+			PTHREAD_RWLOCK_wrlock(&entry->content_lock);
 			mdcache_dirent_invalidate_all(entry);
+			PTHREAD_RWLOCK_unlock(&entry->content_lock);
+		}
 	} else {
 		/* Invalidate attributes of parent and entry */
 		atomic_clear_uint32_t_bits(&parent->mde_flags,
diff --git a/src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_helpers.c b/src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_helpers.c
index be3a084..4dfa976 100644
--- a/src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_helpers.c
+++ b/src/FSAL/Stackable_FSALs/FSAL_MDCACHE/mdcache_helpers.c
@@ -310,8 +310,9 @@ mdc_get_parent(struct mdcache_fsal_export *export, mdcache_entry_t *entry)
 /**
  * @brief Invalidates and releases all cached entries for a directory
  *
- * Invalidates all the entries for a cached directory.  The content
- * lock must be held for write when this function is called.
+ * Invalidates all the entries for a cached directory.
+ *
+ * @note The content lock MUST be held for write
  *
  * @param[in,out] entry  The directory to be managed
  *
-- 
1.8.3.1

