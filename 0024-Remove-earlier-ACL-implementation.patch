From 4eca3fb013423d9640cdb19981a91e3fea8bc3ba Mon Sep 17 00:00:00 2001
From: Jiffin Tony Thottan <jthottan@redhat.com>
Date: Tue, 23 Jun 2015 14:56:37 +0530
Subject: [PATCH] FSAL_GLUSTER : removing previous acl implementation

This patch will remove following api's, macros, structures
related to previous acl implemention from the code base :
* fsal_acl_2_gluster_posix_acl()
* fsal_acl_2_glusterfs_acl()
* glusterfs_acl_2_fsal_acl()
* mode_bits_to_acl()

Change-Id: Id40c891f94f6e2f87206e0dfefecccf6c500273f
Signed-off-by: Jiffin Tony Thottan <jthottan@redhat.com>
---
 src/FSAL/FSAL_GLUSTER/gluster_internal.c | 461 -------------------------------
 src/FSAL/FSAL_GLUSTER/gluster_internal.h | 271 ------------------
 src/FSAL/FSAL_GLUSTER/handle.c           |  13 -
 3 files changed, 745 deletions(-)

diff --git a/src/FSAL/FSAL_GLUSTER/gluster_internal.c b/src/FSAL/FSAL_GLUSTER/gluster_internal.c
index 4ad11e4..d116366 100644
--- a/src/FSAL/FSAL_GLUSTER/gluster_internal.c
+++ b/src/FSAL/FSAL_GLUSTER/gluster_internal.c
@@ -391,94 +391,6 @@ int setglustercreds(struct glusterfs_export *glfs_export, uid_t *uid,
 	return rc;
 }
 
-#ifdef POSIX_ACL_CONVERSION
-/*
- *  Given a FSAL ACL convert it into an equivalent POSIX ACL
- */
-fsal_status_t fsal_acl_2_glusterfs_posix_acl(fsal_acl_t *p_fsalacl,
-				  char *p_buffacl)
-{
-	int i;
-	fsal_ace_t *pace;
-	glusterfs_acl_t *p_glusterfsacl;
-
-	p_glusterfsacl = (glusterfs_acl_t *) p_buffacl;
-
-	p_glusterfsacl->acl_level = 0;
-	p_glusterfsacl->acl_version = GLUSTERFS_ACL_VERSION_POSIX;
-	p_glusterfsacl->acl_type = GLUSTERFS_ACL_TYPE_ACCESS;
-	p_glusterfsacl->acl_nace = 0;
-
-	for (pace = p_fsalacl->aces, i = 0;
-	     pace < p_fsalacl->aces + p_fsalacl->naces; pace++, i++) {
-
-		if (!IS_FSAL_ACE_ALLOW(*pace))
-			continue;
-
-		p_glusterfsacl->acl_nace++;
-		if (IS_FSAL_ACE_SPECIAL_ID(*pace)) {
-			/* POSIX ACLs do not contain IDs for the special ACEs */
-			p_glusterfsacl->ace_v1[i].ace_id =
-				GLUSTERFS_ACL_UNDEFINED_ID;
-			switch (pace->who.uid) {
-			case FSAL_ACE_SPECIAL_OWNER:
-				p_glusterfsacl->ace_v1[i].ace_tag =
-					 GLUSTERFS_ACL_USER_OBJ;
-				break;
-			case FSAL_ACE_SPECIAL_GROUP:
-				p_glusterfsacl->ace_v1[i].ace_tag =
-				       GLUSTERFS_ACL_GROUP_OBJ;
-				break;
-			case FSAL_ACE_SPECIAL_EVERYONE:
-				p_glusterfsacl->ace_v1[i].ace_tag =
-					GLUSTERFS_ACL_OTHER;
-				break;
-			}
-		} else {
-			/*
-			 * TODO: POSIX ACLs do not support multiple USER/GROUP
-			 * Aces with same UID/GID. What about duplicates
-			 */
-			if (IS_FSAL_ACE_GROUP_ID(*pace)) {
-				p_glusterfsacl->ace_v1[i].ace_tag =
-					GLUSTERFS_ACL_GROUP;
-				p_glusterfsacl->ace_v1[i].ace_id =
-					pace->who.gid;
-			} else {
-				p_glusterfsacl->ace_v1[i].ace_tag =
-					GLUSTERFS_ACL_USER;
-				p_glusterfsacl->ace_v1[i].ace_id =
-					pace->who.uid;
-			}
-		}
-		p_glusterfsacl->ace_v1[i].ace_perm = 0;
-		p_glusterfsacl->ace_v1[i].ace_perm |=
-			((pace->perm & ACE4_MASK_READ_DATA) ?
-				GLUSTERFS_ACL_READ : 0);
-		p_glusterfsacl->ace_v1[i].ace_perm |=
-			((pace->perm & ACE4_MASK_WRITE_DATA) ?
-				GLUSTERFS_ACL_WRITE : 0);
-		p_glusterfsacl->ace_v1[i].ace_perm |=
-			((pace->perm & ACE4_MASK_EXECUTE) ?
-				GLUSTERFS_ACL_EXECUTE : 0);
-	}
-	/* TODO: calculate appropriate aceMask */
-	p_glusterfsacl->ace_v1[i].ace_tag = GLUSTERFS_ACL_MASK;
-	p_glusterfsacl->ace_v1[i].ace_perm |=  (GLUSTERFS_ACL_READ |
-							GLUSTERFS_ACL_WRITE);
-	p_glusterfsacl->acl_nace++;
-
-	/* One extra ace for mask */
-	p_glusterfsacl->acl_len =
-	    ((int)(signed long)&(((glusterfs_acl_t *) 0)->ace_v1)) +
-	    (p_glusterfsacl->acl_nace) * sizeof(glusterfs_ace_v1_t);
-
-	/* TODO: Sort the aces in the order of OWNER, USER, GROUP & EVRYONE */
-
-	return fsalstat(ERR_FSAL_NO_ERROR, 0);
-}
-#endif
-
 /*
  * Read the ACL in GlusterFS format and convert it into fsal ACL before
  * storing it in fsalattr
@@ -557,379 +469,6 @@ fsal_status_t glusterfs_set_acl(struct glusterfs_export *glfs_export,
 }
 
 /*
- *  Given a FSAL ACL convert it into GLUSTERFS ACL format.
- *  Also, compute mode-bits equivalent to the ACL set and
- *  store in st_mode.
- */
-fsal_status_t fsal_acl_2_glusterfs_acl(fsal_acl_t *p_fsalacl,
-				  char *p_buffacl, uint32_t *st_mode)
-{
-	int i;
-	fsal_ace_t *pace;
-	glusterfs_acl_t *p_glusterfsacl;
-
-	/* sanity checks */
-	if (!p_fsalacl || !p_buffacl || !st_mode)
-		return fsalstat(ERR_FSAL_FAULT, 0);
-
-	p_glusterfsacl = (glusterfs_acl_t *) p_buffacl;
-
-	p_glusterfsacl->acl_level = 0;
-	p_glusterfsacl->acl_version = GLUSTERFS_ACL_VERSION_NFS4;
-	p_glusterfsacl->acl_type = GLUSTERFS_ACL_TYPE_NFS4;
-	p_glusterfsacl->acl_nace = p_fsalacl->naces;
-	p_glusterfsacl->acl_len =
-	    ((int)(signed long)&(((glusterfs_acl_t *) 0)->ace_v1)) +
-	    p_glusterfsacl->acl_nace * sizeof(glusterfs_ace_v4_t);
-
-	for (pace = p_fsalacl->aces, i = 0;
-	     pace < p_fsalacl->aces + p_fsalacl->naces; pace++, i++) {
-
-		/* check for the unsupported ACE types. */
-		if (!(IS_FSAL_ACE_ALLOW(*pace) ||
-				 IS_FSAL_ACE_DENY(*pace))) {
-			return fsalstat(ERR_FSAL_ATTRNOTSUPP, 0);
-		}
-
-		/*
-		 * Check for unsupported ACE flags
-		 * Apart from 'ACE4_IDENTIFIER_GROUP', currently we do
-		 * not support Inherit and AUDIT/ALARM ACE flags
-		 */
-		if (GET_FSAL_ACE_FLAG(*pace) & ~ACE4_FLAG_SUPPORTED)
-			return fsalstat(ERR_FSAL_ATTRNOTSUPP, 0);
-
-		p_glusterfsacl->ace_v4[i].aceType = pace->type;
-		p_glusterfsacl->ace_v4[i].aceFlags = pace->flag;
-		p_glusterfsacl->ace_v4[i].aceIFlags = pace->iflag;
-		p_glusterfsacl->ace_v4[i].aceMask = pace->perm;
-
-		if (IS_FSAL_ACE_SPECIAL_ID(*pace)) {
-			p_glusterfsacl->ace_v4[i].aceWho = pace->who.uid;
-			if (IS_FSAL_ACE_ALLOW(*pace))
-				CHANGE_MODE_BITS(*pace);
-		} else {
-			if (IS_FSAL_ACE_GROUP_ID(*pace))
-				p_glusterfsacl->ace_v4[i].aceWho =
-					pace->who.gid;
-			else
-				p_glusterfsacl->ace_v4[i].aceWho =
-					pace->who.uid;
-		}
-
-		LogMidDebug(COMPONENT_FSAL,
-			 "fsal_acl_2_glusterfs_acl:glusterfs ace:type = 0x%x, flag = 0x%x, perm = 0x%x, special = %d, %s = 0x%x",
-			 p_glusterfsacl->ace_v4[i].aceType,
-			 p_glusterfsacl->ace_v4[i].aceFlags,
-			 p_glusterfsacl->ace_v4[i].aceMask,
-			 (p_glusterfsacl->ace_v4[i].
-			  aceIFlags & FSAL_ACE_IFLAG_SPECIAL_ID) ? 1 : 0,
-			 (p_glusterfsacl->ace_v4[i].
-			  aceFlags & FSAL_ACE_FLAG_GROUP_ID) ? "gid" : "uid",
-			 p_glusterfsacl->ace_v4[i].aceWho);
-
-	}
-
-	return fsalstat(ERR_FSAL_NO_ERROR, 0);
-}
-
-/*
- *  Given a GLUSTERFS ACL convert it into FSAL ACL format
- */
-int glusterfs_acl_2_fsal_acl(struct attrlist *p_object_attributes,
-			       glusterfs_acl_t *p_glusterfsacl)
-{
-	fsal_acl_status_t status;
-	fsal_acl_data_t acldata;
-	fsal_ace_t *pace = NULL;
-	fsal_acl_t *pacl = NULL;
-	glusterfs_ace_v4_t *pace_glusterfs;
-
-	/* sanity checks */
-	if (!p_object_attributes)
-		return ERR_FSAL_FAULT;
-
-	if (!FSAL_TEST_MASK(p_object_attributes->mask, ATTR_ACL))
-		return ERR_FSAL_ATTRNOTSUPP;
-
-	/* Create fsal acl data. */
-	acldata.naces = (p_glusterfsacl ? p_glusterfsacl->acl_nace : 0);
-	acldata.aces = (fsal_ace_t *) nfs4_ace_alloc(acldata.naces);
-
-	/* return if ACL not present
-	 *
-	 * TODO: should the ACL be built from the p_object_attributes->mode?
-	 */
-	if (!acldata.naces)
-		return ERR_FSAL_NO_ERROR;
-
-	/* Fill fsal acl data from glusterfs acl. */
-	for (pace = acldata.aces, pace_glusterfs = p_glusterfsacl->ace_v4;
-	     pace < acldata.aces + acldata.naces; pace++, pace_glusterfs++) {
-		pace->type = pace_glusterfs->aceType;
-		pace->flag = pace_glusterfs->aceFlags;
-		pace->iflag = pace_glusterfs->aceIFlags;
-		pace->perm = pace_glusterfs->aceMask;
-
-		if (IS_FSAL_ACE_SPECIAL_ID(*pace)) { /* Record special user. */
-			pace->who.uid = pace_glusterfs->aceWho;
-		} else {
-			if (IS_FSAL_ACE_GROUP_ID(*pace))
-				pace->who.gid = pace_glusterfs->aceWho;
-			else	/* Record user. */
-				pace->who.uid = pace_glusterfs->aceWho;
-		}
-
-		LogMidDebug(COMPONENT_FSAL,
-			 "glusterfs_acl_2_fsal_acl: fsal ace: type = 0x%x, flag = 0x%x, perm = 0x%x, special = %d, %s = 0x%x",
-			 pace->type, pace->flag, pace->perm,
-			 IS_FSAL_ACE_SPECIAL_ID(*pace),
-			 GET_FSAL_ACE_WHO_TYPE(*pace), GET_FSAL_ACE_WHO(*pace));
-	}
-
-	/* Create a new hash table entry for fsal acl. */
-	pacl = nfs4_acl_new_entry(&acldata, &status);
-	LogMidDebug(COMPONENT_FSAL, "fsal acl = %p, fsal_acl_status = %u", pacl,
-		 status);
-
-	if (pacl == NULL) {
-		LogCrit(COMPONENT_FSAL,
-			"glusterfs_acl_2_fsal_acl: failed to create a new acl entry");
-		return ERR_FSAL_FAULT;
-	}
-
-	/* Add fsal acl to attribute. */
-	p_object_attributes->acl = pacl;
-
-	return ERR_FSAL_NO_ERROR;
-}
-
-/*
- *  Given mode-bits, first verify if the object already has an ACL set.
- *  Only if there is an ACL present, modify it accordingly as per
- *  the mode-bits set.
- */
-fsal_status_t mode_bits_to_acl(struct glfs *fs,
-			       struct glusterfs_handle *objhandle,
-			       struct attrlist *attrs, int *attrs_valid,
-			       glusterfs_fsal_xstat_t *buffxstat,
-			       bool is_dir)
-{
-	fsal_status_t status = { ERR_FSAL_NO_ERROR, 0 };
-	int rc = 0;
-	char *acl_key = "user.nfsv4_acls";
-	glusterfs_acl_t *p_glusterfsacl;
-	glusterfs_ace_v4_t *pace_Aowner = NULL;
-	glusterfs_ace_v4_t *pace_Downer = NULL;
-	glusterfs_ace_v4_t *pace_Agroup = NULL;
-	glusterfs_ace_v4_t *pace_Dgroup = NULL;
-	glusterfs_ace_v4_t *pace_Aeveryone = NULL;
-	glusterfs_ace_v4_t *pace_Deveryone = NULL;
-	glusterfs_ace_v4_t *pace = NULL;
-	fsal_ace_t face;
-	bool read_owner = false;
-	bool write_owner = false;
-	bool execute_owner = false;
-	bool read_group = false;
-	bool write_group = false;
-	bool execute_group = false;
-	bool read_everyone = false;
-	bool write_everyone = false;
-	bool execute_everyone = false;
-
-	rc = glfs_h_getxattrs(fs, objhandle->glhandle,
-			      acl_key, buffxstat->buffacl,
-			      GLFS_ACL_BUF_SIZE);
-	if (rc == 0 || (rc == -1 && errno == ENOATTR)) {
-		/* No ACL found
-		   TODO : Do we need to construct aces?
-		   TODO: check for failure conditions */
-		LogFullDebug(COMPONENT_FSAL, "no ACL-xattr set");
-		goto out;
-	} else if (rc == -1) {
-		LogMajor(COMPONENT_FSAL, "failed to fetch ACL");
-		status = fsalstat(ERR_FSAL_SERVERFAULT, errno);
-		goto out;
-	}
-	/* there is an existing acl. modify it */
-	FSAL_SET_MASK(*attrs_valid, XATTR_ACL);
-
-	p_glusterfsacl = (glusterfs_acl_t *)buffxstat->buffacl;
-
-	read_owner = IS_READ_OWNER(attrs->mode);
-	write_owner = IS_WRITE_OWNER(attrs->mode);
-	execute_owner = IS_EXECUTE_OWNER(attrs->mode);
-	read_group = IS_READ_GROUP(attrs->mode);
-	write_group = IS_WRITE_GROUP(attrs->mode);
-	execute_group = IS_EXECUTE_GROUP(attrs->mode);
-	read_everyone = IS_READ_OTHERS(attrs->mode);
-	write_everyone = IS_WRITE_OTHERS(attrs->mode);
-	execute_everyone = IS_EXECUTE_OTHERS(attrs->mode);
-
-	for (pace = p_glusterfsacl->ace_v4;
-	     pace < p_glusterfsacl->ace_v4 + p_glusterfsacl->acl_nace;
-	     pace++) {
-		/* TODO: try to avoid converting it to FSAL ACE format */
-		face.type = pace->aceType;
-		face.flag = pace->aceFlags;
-		face.iflag = pace->aceIFlags;
-		face.who.uid = pace->aceWho;
-
-		if (IS_FSAL_ACE_ALLOW(face)) {
-			if (IS_FSAL_ACE_SPECIAL_ID(face)) {
-				/* NULL out the mask */
-				pace->aceMask = 0;
-				if (IS_FSAL_ACE_SPECIAL_OWNER(face)) {
-					pace_Aowner = pace;
-				} else if (IS_FSAL_ACE_SPECIAL_GROUP(face)) {
-					pace_Agroup = pace;
-				} else { /* everyone */
-					pace_Aeveryone = pace;
-				}
-			}
-			pace->aceMask |= ACE4_OTHERS_AUTOSET;
-		} else { /* deny ace */
-			if (IS_FSAL_ACE_SPECIAL_ID(face)) {
-				if (IS_FSAL_ACE_SPECIAL_OWNER(face)) {
-					pace_Downer = pace;
-				} else if (IS_FSAL_ACE_SPECIAL_GROUP(face)) {
-					pace_Dgroup = pace;
-				} else { /* everyone */
-					pace_Deveryone = pace;
-				}
-			}
-			pace->aceMask &= ~(ACE4_OTHERS_AUTOSET);
-		}
-	}
-
-	/*
-	 *  Now add the missing Allow aces (if any) at the end in the order of
-	 *  OWNER@, GROUP@, EVERYONE@. Deny aces need not be added as the masks
-	 *  will by default be denied if not present in the Allow ace.
-	 */
-	if (!pace_Aowner) {
-		p_glusterfsacl->acl_nace++;
-		p_glusterfsacl->acl_len += sizeof(glusterfs_ace_v4_t);
-		pace->aceType = FSAL_ACE_TYPE_ALLOW;
-		pace->aceIFlags = FSAL_ACE_IFLAG_SPECIAL_ID;
-		pace->aceFlags = 0;
-		pace->aceMask = 0;
-		/* No need to set aceFlags as its default ace */
-		pace->aceWho = FSAL_ACE_SPECIAL_OWNER;
-		pace->aceMask |= ACE4_OTHERS_AUTOSET;
-		pace_Aowner = pace;
-		pace++;
-	}
-	if (!pace_Agroup) {
-		p_glusterfsacl->acl_nace++;
-		p_glusterfsacl->acl_len += sizeof(glusterfs_ace_v4_t);
-		pace->aceType = FSAL_ACE_TYPE_ALLOW;
-		pace->aceIFlags = FSAL_ACE_IFLAG_SPECIAL_ID;
-		pace->aceFlags = 0;
-		pace->aceMask = 0;
-		/* No need to set aceFlags as its default ace*/
-		pace->aceWho = FSAL_ACE_SPECIAL_GROUP;
-		pace->aceMask |= ACE4_OTHERS_AUTOSET;
-		pace_Agroup = pace;
-		pace++;
-	}
-	if (!pace_Aeveryone) {
-		p_glusterfsacl->acl_nace++;
-		p_glusterfsacl->acl_len += sizeof(glusterfs_ace_v4_t);
-		pace->aceType = FSAL_ACE_TYPE_ALLOW;
-		pace->aceIFlags = FSAL_ACE_IFLAG_SPECIAL_ID;
-		pace->aceFlags = 0;
-		pace->aceMask = 0;
-		/* No need to set aceFlags as its default ace */
-		pace->aceWho = FSAL_ACE_SPECIAL_EVERYONE;
-		pace->aceMask |= ACE4_OTHERS_AUTOSET;
-		pace_Aeveryone = pace;
-		pace++;
-	}
-
-	/* Now adjust perms for special aces */
-	if (pace_Aowner) {
-		pace_Aowner->aceMask |= ACE4_OWNER_AUTOSET;
-		if (read_owner) {
-			pace_Aowner->aceMask |=
-			     is_dir ? ACE4_READ_DIR_ALL : ACE4_READ_ALL;
-		}
-		if (write_owner) {
-			pace_Aowner->aceMask |=
-			     is_dir ? ACE4_WRITE_DIR_ALL : ACE4_WRITE_ALL;
-		}
-		if (execute_owner)
-			pace_Aowner->aceMask |= ACE4_EXECUTE_ALL;
-	}
-	if (pace_Downer) {
-		pace_Downer->aceMask &= ~(ACE4_OWNER_AUTOSET);
-		if (read_owner) {
-			pace_Downer->aceMask &=
-			     is_dir ? ~(ACE4_READ_DIR_ALL) : ~(ACE4_READ_ALL);
-		}
-		if (write_owner) {
-			pace_Downer->aceMask &=
-			     is_dir ? ~(ACE4_WRITE_DIR_ALL) : ~(ACE4_WRITE_ALL);
-		}
-		if (execute_owner)
-			pace_Downer->aceMask &= is_dir ? : ~(ACE4_EXECUTE_ALL);
-	}
-	if (pace_Agroup) {
-		if (read_group) {
-			pace_Agroup->aceMask |=
-			     is_dir ? ACE4_READ_DIR_ALL : ACE4_READ_ALL;
-		}
-		if (write_group) {
-			pace_Agroup->aceMask |=
-			     is_dir ? ACE4_WRITE_DIR_ALL : ACE4_WRITE_ALL;
-		}
-		if (execute_group)
-			pace_Agroup->aceMask |= ACE4_EXECUTE_ALL;
-	}
-	if (pace_Dgroup) {
-		if (read_group) {
-			pace_Dgroup->aceMask &=
-			     is_dir ? ~(ACE4_READ_DIR_ALL) : ~(ACE4_READ_ALL);
-		}
-		if (write_group) {
-			pace_Dgroup->aceMask &=
-			     is_dir ? ~(ACE4_WRITE_DIR_ALL) : ~(ACE4_WRITE_ALL);
-		}
-		if (execute_group)
-			pace_Dgroup->aceMask &= is_dir ? : ~(ACE4_EXECUTE_ALL);
-	}
-	if (pace_Aeveryone) {
-		if (read_everyone) {
-			pace_Aeveryone->aceMask |=
-			     is_dir ? ACE4_READ_DIR_ALL : ACE4_READ_ALL;
-		}
-		if (write_everyone) {
-			pace_Aeveryone->aceMask |=
-			     is_dir ? ACE4_WRITE_DIR_ALL : ACE4_WRITE_ALL;
-		}
-		if (execute_everyone)
-			pace_Aeveryone->aceMask |= ACE4_EXECUTE_ALL;
-	}
-	if (pace_Deveryone) {
-		if (read_everyone) {
-			pace_Deveryone->aceMask &=
-			     is_dir ? ~(ACE4_READ_DIR_ALL) : ~(ACE4_READ_ALL);
-		}
-		if (write_everyone) {
-			pace_Deveryone->aceMask &=
-			     is_dir ? ~(ACE4_WRITE_DIR_ALL) : ~(ACE4_WRITE_ALL);
-		}
-		if (execute_everyone) {
-			pace_Deveryone->aceMask &=
-			     is_dir ? : ~(ACE4_EXECUTE_ALL);
-		}
-	}
-
-out:
-	return status;
-}
-
-/*
  *  Process NFSv4 ACLs passed in setattr call
  */
 fsal_status_t glusterfs_process_acl(struct glfs *fs,
diff --git a/src/FSAL/FSAL_GLUSTER/gluster_internal.h b/src/FSAL/FSAL_GLUSTER/gluster_internal.h
index 58e62c8..67c8e0f 100644
--- a/src/FSAL/FSAL_GLUSTER/gluster_internal.h
+++ b/src/FSAL/FSAL_GLUSTER/gluster_internal.h
@@ -88,225 +88,13 @@ ATTR_ACL)
 		GFAPI_HANDLE_LENGTH +	\
 		GLAPI_UUID_LENGTH)
 
-/*
- * Macros related to ACL processing
- */
-
 /* Flags to determine if ACLs are supported */
 #define NFSv4_ACL_SUPPORT (glfs_export->acl_enable)
-#define POSIX_ACL_CONVERSION 0
 
 /* define flags for attr_valid */
 #define XATTR_STAT      (1 << 0) /* 01 */
 #define XATTR_ACL       (1 << 1) /* 02 */
 
-/* Checks to verify if appropriate masks are set */
-#define IS_READ_OWNER(mask) (S_IRUSR & mask)
-#define IS_WRITE_OWNER(mask) (S_IWUSR & mask)
-#define IS_EXECUTE_OWNER(mask) (S_IXUSR & mask)
-#define IS_READ_GROUP(mask) (S_IRGRP & mask)
-#define IS_WRITE_GROUP(mask) (S_IWGRP & mask)
-#define IS_EXECUTE_GROUP(mask) (S_IXGRP & mask)
-#define IS_READ_OTHERS(mask) (S_IROTH & mask)
-#define IS_WRITE_OTHERS(mask) (S_IWOTH & mask)
-#define IS_EXECUTE_OTHERS(mask) (S_IXOTH & mask)
-
-/* Bits which need to be cleared before calculating equivalent
- * modebits from an ACL
- */
-#define CLEAR_MODE_BITS ((0xFFFF &	\
-			    ~(S_IRUSR | S_IWUSR | S_IXUSR |  \
-			      S_IRGRP | S_IWGRP | S_IXGRP |  \
-			      S_IROTH | S_IWOTH | S_IXOTH)))
-
-/* ACL types (acl_type field in glusterfs_acl_t) */
-#define GLUSTERFS_ACL_TYPE_ACCESS  1
-#define GLUSTERFS_ACL_TYPE_DEFAULT 2
-#define GLUSTERFS_ACL_TYPE_NFS4    3
-
-/* Defined values for glusterfs_aclVersion_t */
-#define GLUSTERFS_ACL_VERSION_POSIX   2
-#define GLUSTERFS_ACL_VERSION_NFS4    4
-
-/* Values for glusterfs_aclLevel_t  */
-#define GLUSTERFS_ACL_LEVEL_BASE    0/*compatible with all acl_version values */
-#define GLUSTERFS_ACL_LEVEL_V4FLAGS 1/* requires GLUSTERFS_ACL_VERSION_NFS4 */
-
-/* Values for glusterfs_aceType_t (ACL_VERSION_POSIX) */
-#define GLUSTERFS_ACL_UNDEFINED_TAG	0
-#define GLUSTERFS_ACL_USER_OBJ		1
-#define GLUSTERFS_ACL_USER		2
-#define GLUSTERFS_ACL_GROUP_OBJ		4
-#define GLUSTERFS_ACL_GROUP		8
-#define GLUSTERFS_ACL_MASK		10
-#define GLUSTERFS_ACL_OTHER		20
-
-/* Values for glusterfs_acePerm_t (ACL_VERSION_POSIX) */
-#define GLUSTERFS_ACL_EXECUTE 001
-#define GLUSTERFS_ACL_WRITE   002
-#define GLUSTERFS_ACL_READ    004
-
-/* Values for glusterfs_uid_t (ACL_VERSION_POSIX) */
-#define GLUSTERFS_ACL_UNDEFINED_ID  (-1)
-
-/* Values for glusterfs_aceType_t (ACL_VERSION_NFS4) */
-#define ACE4_TYPE_ALLOW 0
-#define ACE4_TYPE_DENY  1
-#define ACE4_TYPE_AUDIT 2
-#define ACE4_TYPE_ALARM 3
-
-/* Values for glusterfs_aceFlags_t (ACL_VERSION_NFS4) */
-#define ACE4_FLAG_FILE_INHERIT    0x00000001
-#define ACE4_FLAG_DIR_INHERIT     0x00000002
-#define ACE4_FLAG_NO_PROPAGATE    0x00000004
-#define ACE4_FLAG_INHERIT_ONLY    0x00000008
-#define ACE4_FLAG_SUCCESSFUL      0x00000010
-#define ACE4_FLAG_FAILED	  0x00000020
-#define ACE4_FLAG_GROUP_ID	  0x00000040
-#define ACE4_FLAG_INHERITED       0x00000080
-
-/* Currently we do not support Inherited ACLs or AUDIT/ALARM ACLs.
- * Hence the only ACE flag supported is ACE4_FLAG_GROUP_ID */
-#define ACE4_FLAG_SUPPORTED     (ACE4_FLAG_GROUP_ID)
-
-/* GLUSTERFS-defined flags.  Placed in a seperate ACL field to avoid
-   ever running into newly defined NFSv4 flags. */
-#define ACE4_IFLAG_SPECIAL_ID      0x80000000
-
-/* Values for glusterfs_aceMask_t (ACL_VERSION_NFS4) */
-#define ACE4_MASK_READ_DATA	    0x00000001
-#define ACE4_MASK_LIST_DIRECTORY    0x00000001
-#define ACE4_MASK_WRITE_DATA	    0x00000002
-#define ACE4_MASK_ADD_FILE	    0x00000002
-#define ACE4_MASK_APPEND_DATA       0x00000004
-#define ACE4_MASK_ADD_SUBDIRECTORY  0x00000004
-#define ACE4_MASK_READ_NAMED_ATTRS  0x00000008
-#define ACE4_MASK_WRITE_NAMED_ATTRS 0x00000010
-#define ACE4_MASK_EXECUTE	    0x00000020
-
-/* The rfc doesn't provide a mask equivalent to "search" ("x" on a
- * directory in posix), but it also doesn't say that its EXECUTE
- * is to have this dual use (even though it does so for other dual
- * use permissions such as read/list.  Going to make the assumption
- * here that the EXECUTE bit has this dual meaning... otherwise
- * we're left with no control over search.
- */
-#define ACE4_MASK_SEARCH	    0x00000020
-
-#define ACE4_MASK_DELETE_CHILD      0x00000040
-#define ACE4_MASK_READ_ATTRIBUTES   0x00000080
-#define ACE4_MASK_WRITE_ATTRIBUTES  0x00000100
-#define ACE4_MASK_DELETE	    0x00010000
-#define ACE4_MASK_READ_ACL	    0x00020000
-#define ACE4_MASK_WRITE_ACL	    0x00040000
-#define ACE4_MASK_WRITE_OWNER       0x00080000
-#define ACE4_MASK_SYNCHRONIZE       0x00100000
-#define ACE4_MASK_ALL		    0x001f01ff
-
-/* To set appropriate ACE masks as per perms set */
-#define ACE4_READ_ALL	    (ACE4_MASK_READ_DATA   | \
-			      ACE4_MASK_READ_NAMED_ATTRS)
-#define ACE4_WRITE_ALL	    (ACE4_MASK_WRITE_DATA  | \
-			      ACE4_MASK_APPEND_DATA | \
-			      ACE4_MASK_WRITE_NAMED_ATTRS)
-#define ACE4_READ_DIR_ALL   (ACE4_MASK_LIST_DIRECTORY   | \
-			      ACE4_MASK_READ_NAMED_ATTRS)
-#define ACE4_WRITE_DIR_ALL  (ACE4_MASK_ADD_FILE  | \
-			      ACE4_MASK_ADD_SUBDIRECTORY | \
-			      ACE4_MASK_DELETE_CHILD | \
-			      ACE4_MASK_WRITE_NAMED_ATTRS)
-#define ACE4_EXECUTE_ALL    (ACE4_MASK_EXECUTE     | \
-			      ACE4_MASK_READ_DATA)
-#define ACE4_WRITE	    (ACE4_MASK_WRITE_DATA | \
-			      ACE4_MASK_APPEND_DATA)
-#define ACE4_OWNER_AUTOSET  (ACE4_MASK_WRITE_ACL | \
-			      ACE4_MASK_WRITE_ATTRIBUTES | \
-			      ACE4_MASK_READ_ACL | \
-			      ACE4_MASK_READ_ATTRIBUTES | \
-			      ACE4_MASK_SYNCHRONIZE)
-#define ACE4_OTHERS_AUTOSET (ACE4_MASK_READ_ACL | \
-			      ACE4_MASK_READ_ATTRIBUTES | \
-			      ACE4_MASK_SYNCHRONIZE)
-
-/* Checks to verify ACE mask values */
-#define IS_ACE4_READ(mask)  (mask & ACE4_MASK_READ_DATA)
-#define IS_ACE4_WRITE(mask) ((mask & ACE4_MASK_WRITE_DATA) && \
-			       (mask & ACE4_MASK_APPEND_DATA))
-#define IS_ACE4_EXECUTE(mask)  (mask & ACE4_MASK_EXECUTE)
-
-/* Conversion from ACE to mode-bits */
-#define CHANGE_MODE_BITS(ACE) \
-	do {			\
-		if (IS_FSAL_ACE_SPECIAL_OWNER(ACE)) {	\
-			*st_mode |= IS_ACE4_READ(GET_FSAL_ACE_PERM(ACE)) \
-				? S_IRUSR : 0; \
-			*st_mode |= IS_ACE4_WRITE(GET_FSAL_ACE_PERM(ACE)) \
-				? S_IWUSR : 0; \
-			*st_mode |= IS_ACE4_EXECUTE(GET_FSAL_ACE_PERM(ACE)) \
-				? S_IXUSR : 0; \
-		}					\
-		else if (IS_FSAL_ACE_SPECIAL_GROUP(ACE)) {	\
-			*st_mode |= IS_ACE4_READ(GET_FSAL_ACE_PERM(ACE)) \
-				? S_IRGRP : 0; \
-			*st_mode |= IS_ACE4_WRITE(GET_FSAL_ACE_PERM(ACE)) \
-				? S_IWGRP : 0; \
-			*st_mode |= IS_ACE4_EXECUTE(GET_FSAL_ACE_PERM(ACE)) \
-				? S_IXGRP : 0; \
-		}					\
-		else if (IS_FSAL_ACE_SPECIAL_EVERYONE(ACE)) {	\
-			*st_mode |= IS_ACE4_READ(GET_FSAL_ACE_PERM(ACE)) \
-				? S_IROTH : 0; \
-			*st_mode |= IS_ACE4_WRITE(GET_FSAL_ACE_PERM(ACE)) \
-				? S_IWOTH : 0; \
-			*st_mode |= IS_ACE4_EXECUTE(GET_FSAL_ACE_PERM(ACE)) \
-				? S_IXOTH : 0; \
-		}					\
-		else { \
-			/* Code shouldn't reach here */ \
-		}	\
-	} while (0)
-
-/* Values for glusterfs_uid_t (ACL_VERSION_NFS4) */
-#define ACE4_SPECIAL_OWNER	      1
-#define ACE4_SPECIAL_GROUP	      2
-#define ACE4_SPECIAL_EVERYONE	      3
-
-/* per-ACL flags imported from a Windows security descriptor object */
-#define ACL4_FLAG_OWNER_DEFAULTED	       0x00000100
-#define ACL4_FLAG_GROUP_DEFAULTED	       0x00000200
-#define ACL4_FLAG_DACL_PRESENT		       0x00000400
-#define ACL4_FLAG_DACL_DEFAULTED	       0x00000800
-#define ACL4_FLAG_SACL_PRESENT		       0x00001000
-#define ACL4_FLAG_SACL_DEFAULTED	       0x00002000
-#define ACL4_FLAG_DACL_UNTRUSTED	       0x00004000
-#define ACL4_FLAG_SERVER_SECURITY	       0x00008000
-#define ACL4_FLAG_DACL_AUTO_INHERIT_REQ	       0x00010000
-#define ACL4_FLAG_SACL_AUTO_INHERIT_REQ	       0x00020000
-#define ACL4_FLAG_DACL_AUTO_INHERITED	       0x00040000
-#define ACL4_FLAG_SACL_AUTO_INHERITED	       0x00080000
-#define ACL4_FLAG_DACL_PROTECTED	       0x00100000
-#define ACL4_FLAG_SACL_PROTECTED	       0x00200000
-#define ACL4_FLAG_RM_CONTROL_VALID	       0x00400000
-#define ACL4_FLAG_NULL_DACL		       0x00800000
-#define ACL4_FLAG_NULL_SACL		       0x01000000
-#define ACL4_FLAG_VALID_FLAGS		       0x01ffff00
-
-
-typedef unsigned int glusterfs_uid_t;
-
-/* Externalized ACL defintions */
-typedef unsigned int glusterfs_aclType_t;
-typedef unsigned int glusterfs_aclLen_t;
-typedef unsigned int glusterfs_aclLevel_t;
-typedef unsigned int glusterfs_aclVersion_t;
-typedef unsigned int glusterfs_aclCount_t;
-typedef unsigned int glusterfs_aclFlag_t;
-
-typedef unsigned int glusterfs_aceType_t;
-typedef unsigned int glusterfs_aceFlags_t;
-typedef unsigned int glusterfs_acePerm_t;
-typedef unsigned int glusterfs_aceMask_t;
-
 /* END Override */
 
 #ifdef GLTIMING
@@ -399,29 +187,6 @@ struct glfs_ds_wire {
 	struct glfs_file_layout layout; /*< Layout information */
 };
 
-
-/* A POSIX ACL Entry */
-typedef struct glusterfs_ace_v1 {
-	glusterfs_aceType_t  ace_tag; /* POSIX ACE type */
-	glusterfs_acePerm_t  ace_perm; /* POSIX permissions */
-	glusterfs_uid_t      ace_id;  /* uid/gid */
-} glusterfs_ace_v1_t;
-
-/* A NFSv4 ACL Entry */
-typedef struct glusterfs_ace_v4 {
-	glusterfs_aceType_t  aceType;   /* Allow or Deny */
-	glusterfs_aceFlags_t aceFlags;  /* Inherit specifications, etc. */
-	glusterfs_aceFlags_t aceIFlags; /* GLUSTERFS Internal flags */
-	glusterfs_aceMask_t  aceMask;   /* NFSv4 mask specification */
-	glusterfs_uid_t      aceWho;    /* User/Group identification */
-} glusterfs_ace_v4_t;
-
-/* when GLUSTERFS_ACL_VERSION_NFS4, and GLUSTERFS_ACL_LEVEL_V4FLAGS */
-typedef struct v4Level1_ext { /* ACL extension */
-	glusterfs_aclFlag_t acl_flags; /* per-ACL flags */
-	glusterfs_ace_v4_t ace_v4[1];
-} v4Level1_t;
-
 /* Define the buffer size for GLUSTERFS NFS4 ACL. */
 #define GLFS_ACL_BUF_SIZE 0x1000
 
@@ -435,26 +200,6 @@ typedef struct fsal_xstat__ {
 	bool is_dir;
 } glusterfs_fsal_xstat_t;
 
-/* GLUSTERFS ACL */
-typedef struct glusterfs_acl {
-	glusterfs_aclLen_t     acl_len; /* Total length of this ACL in bytes */
-	glusterfs_aclLevel_t   acl_level;   /* Reserved (must be zero) */
-	glusterfs_aclType_t    acl_type;    /* Access, Default, or NFS4 */
-	glusterfs_aclCount_t   acl_nace;    /* Number of Entries that follow */
-	glusterfs_aclVersion_t acl_version; /* POSIX or NFS4 ACL */
-	union {
-	glusterfs_ace_v1_t  ace_v1[1]; /* when GLUSTERFS_ACL_VERSION_POSIX */
-	glusterfs_ace_v4_t  ace_v4[1]; /* when GLUSTERFS_ACL_VERSION_NFS4  */
-	v4Level1_t     v4Level1;  /* when GLUSTERFS_ACL_LEVEL_V4FLAGS */
-	};
-} glusterfs_acl_t;
-
-/* POSIX ACL */
-typedef struct glusterfs_posix_acl_header {
-	uint32_t version;
-	glusterfs_ace_v1_t ace_v1[];
-} glusterfs_posix_acl_t;
-
 #ifdef GLTIMING
 struct latency_data glfsal_latencies[LATENCY_SLOTS];
 
@@ -500,27 +245,11 @@ fsal_status_t glusterfs_set_acl(struct glusterfs_export *glfs_export,
 				 struct glusterfs_handle *objhandle,
 				 glusterfs_fsal_xstat_t *buffxstat);
 
-fsal_status_t fsal_acl_2_glusterfs_acl(fsal_acl_t *p_fsalacl,
-				       char *p_buffacl,
-				       uint32_t *st_mode);
-
-int glusterfs_acl_2_fsal_acl(struct attrlist *p_object_attributes,
-			     glusterfs_acl_t *p_glusterfsacl);
-
-fsal_status_t fsal_acl_2_glusterfs_posix_acl(fsal_acl_t *p_fsalacl,
-					     char *p_buffacl);
-
 fsal_status_t glusterfs_process_acl(struct glfs *fs,
 				    struct glfs_object *object,
 				    struct attrlist *attrs,
 				    glusterfs_fsal_xstat_t *buffxstat);
 
-fsal_status_t mode_bits_to_acl(struct glfs *fs,
-			       struct glusterfs_handle *objhandle,
-			       struct attrlist *attrs, int *attrs_valid,
-			       glusterfs_fsal_xstat_t *buffxstat,
-			       bool is_dir);
-
 /*
  * Following have been introduced for pNFS support
  */
diff --git a/src/FSAL/FSAL_GLUSTER/handle.c b/src/FSAL/FSAL_GLUSTER/handle.c
index e4ac16d..2121b03 100644
--- a/src/FSAL/FSAL_GLUSTER/handle.c
+++ b/src/FSAL/FSAL_GLUSTER/handle.c
@@ -812,19 +812,6 @@ static fsal_status_t setattrs(struct fsal_obj_handle *obj_hdl,
 			/* setting the ACL will set the */
 			/* mode-bits too if not already passed */
 			FSAL_SET_MASK(mask, GLAPI_SET_ATTR_MODE);
-		} else if (mask & GLAPI_SET_ATTR_MODE) {
-#if 0
-			bool is_dir = 0;
-			switch (obj_hdl->type) {
-			case REGULAR_FILE:
-				is_dir = 0; break;
-			case DIRECTORY:
-				is_dir = 1; break;
-			default:
-				break;
-			}
-#endif
-
 		}
 	} else if (FSAL_TEST_MASK(attrs->mask, ATTR_ACL)) {
 		status = fsalstat(ERR_FSAL_ATTRNOTSUPP, 0);
-- 
2.1.0

