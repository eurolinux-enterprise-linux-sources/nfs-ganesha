From d75e0fcd54144029a30d98c8046160e220c98abe Mon Sep 17 00:00:00 2001
From: Jiffin Tony Thottan <jthottan@redhat.com>
Date: Thu, 18 Jun 2015 15:51:28 +0530
Subject: [PATCH 2/3] FSAL_GLUSTER : clean up patch for nfs4_acl <-> posix_acl
 conversion

There were a lot of code duplications and loops in previous acl patches
for FSAL_GLUSTER. This will handle those , plus address left out comments
in the previous acl patch https://review.gerrithub.io/#/c/235200/

Change-Id: I656ad4a89c807948dad44e3af4b3b31480b6f0d8
Signed-off-by: Jiffin Tony Thottan <jthottan@redhat.com>
---
 src/FSAL/FSAL_GLUSTER/gluster_internal.c |  74 ++-
 src/FSAL/FSAL_GLUSTER/posix_acls.c       | 912 ++++++++++---------------------
 src/FSAL/FSAL_GLUSTER/posix_acls.h       |  20 +-
 3 files changed, 332 insertions(+), 674 deletions(-)

diff --git a/src/FSAL/FSAL_GLUSTER/gluster_internal.c b/src/FSAL/FSAL_GLUSTER/gluster_internal.c
index cff83c4..275c0ed 100644
--- a/src/FSAL/FSAL_GLUSTER/gluster_internal.c
+++ b/src/FSAL/FSAL_GLUSTER/gluster_internal.c
@@ -32,6 +32,7 @@
 #include "fsal_convert.h"
 #include "nfs4_acls.h"
 #include "FSAL/fsal_commonlib.h"
+#include "posix_acls.h"
 
 /**
  * @brief FSAL status mapping from GlusterFS errors
@@ -400,43 +401,60 @@ fsal_status_t glusterfs_get_acl(struct glusterfs_export *glfs_export,
 				glusterfs_fsal_xstat_t *buffxstat,
 				struct attrlist *fsalattr)
 {
-	fsal_status_t status = { ERR_FSAL_NO_ERROR, 0 };
-	fsalattr->acl = NULL;
+	fsal_status_t status;
+	fsal_acl_data_t acldata;
+	fsal_acl_status_t aclstatus;
+	fsal_ace_t *pace = NULL;
+	int e_count = 0, i_count = 0, ret = 0;
 
+	fsalattr->acl = NULL;
 	if (NFSv4_ACL_SUPPORT && FSAL_TEST_MASK(fsalattr->mask, ATTR_ACL)) {
 
 		buffxstat->e_acl = glfs_h_acl_get(glfs_export->gl_fs,
-						glhandle,
-						ACL_TYPE_ACCESS);
-		if (buffxstat->e_acl) {
-			/* rc is the size of buffacl */
-			FSAL_SET_MASK(buffxstat->attr_valid, XATTR_ACL);
-			/* For directories consider inherited acl too */
-			if (buffxstat->is_dir) {
-				buffxstat->i_acl = glfs_h_acl_get(
-						glfs_export->gl_fs,
-						glhandle, ACL_TYPE_DEFAULT);
-				if (!buffxstat->i_acl)
-					LogDebug(COMPONENT_FSAL,
-				"inherited acl is not defined for directory");
+						glhandle, ACL_TYPE_ACCESS);
+
+		status = gluster2fsal_error(errno);
 
-				status = posix_acl_2_fsal_acl_for_dir(
-						buffxstat->e_acl,
-						buffxstat->i_acl,
-						&fsalattr->acl);
-			} else
-				status = posix_acl_2_fsal_acl(buffxstat->e_acl,
-						&fsalattr->acl);
-			LogFullDebug(COMPONENT_FSAL, "acl = %p", fsalattr->acl);
-		} else {
-			/* some real error occurred */
-			LogMajor(COMPONENT_FSAL, "failed to fetch ACL");
-			status = gluster2fsal_error(errno);
+		e_count = ace_count(buffxstat->e_acl);
+
+		if (buffxstat->is_dir) {
+			buffxstat->i_acl = glfs_h_acl_get(glfs_export->gl_fs,
+						glhandle, ACL_TYPE_DEFAULT);
+			i_count = ace_count(buffxstat->i_acl);
 		}
 
+		acldata.naces = e_count + i_count;
+
+		LogDebug(COMPONENT_FSAL, "No of aces present in fsal_acl_t = %d"
+					, acldata.naces);
+		if (!acldata.naces)
+			return status;
+
+		FSAL_SET_MASK(buffxstat->attr_valid, XATTR_ACL);
+
+		acldata.aces = (fsal_ace_t *) nfs4_ace_alloc(acldata.naces);
+		pace = acldata.aces;
+
+		ret = posix_acl_2_fsal_acl(buffxstat->e_acl,
+					buffxstat->is_dir, false, &pace);
+		if (i_count > 0)
+			ret = posix_acl_2_fsal_acl(buffxstat->i_acl,
+						true, true, &pace);
+		if (ret < 0)
+			return fsalstat(ERR_FSAL_NOENT, -1);
+
+		fsalattr->acl = nfs4_acl_new_entry(&acldata, &aclstatus);
+		LogDebug(COMPONENT_FSAL, "fsal acl = %p, fsal_acl_status = %u",
+				fsalattr->acl, aclstatus);
+		if (fsalattr->acl == NULL) {
+			LogCrit(COMPONENT_FSAL,
+			"failed to create a new acl entry");
+			return fsalstat(ERR_FSAL_NOMEM, -1);
+		}
 	}
 
-	return status;
+	return fsalstat(ERR_FSAL_NO_ERROR, 0);
+
 }
 
 /*
diff --git a/src/FSAL/FSAL_GLUSTER/posix_acls.c b/src/FSAL/FSAL_GLUSTER/posix_acls.c
index 566b1b1..854aa8f 100644
--- a/src/FSAL/FSAL_GLUSTER/posix_acls.c
+++ b/src/FSAL/FSAL_GLUSTER/posix_acls.c
@@ -28,10 +28,6 @@
  */
 
 
-#include <acl/libacl.h>
-#include "nfs4_acls.h"
-#include "fsal_types.h"
-#include <sys/acl.h>
 #include "posix_acls.h"
 
 /* Checks whether ACE belongs to effective acl (ACCESS TYPE) */
@@ -62,33 +58,64 @@ is_ace_valid_for_inherited_acl_entry(fsal_ace_t *ace) {
 
 }
 
-/* add permissions in posix acl entry according to allow ace */
-void
-convert_allow_entry_to_posix(fsal_ace_t *ace, acl_permset_t *p_permset) {
+/*
+ * Check whether given perm(ACL_READ, ACL_WRITE or ACL_EXECUTE) is allowed for
+ * a permset, it depends on given ace and permset of @EVERYONE entry.
+ */
+bool
+isallow(fsal_ace_t *ace, acl_permset_t everyone, acl_perm_t perm) {
+
+	bool ret = acl_get_perm(everyone, perm);
+
+	switch (perm) {
+	case ACL_READ:
+		ret |= IS_FSAL_ACE_READ_DATA(*ace);
+		break;
+	case ACL_WRITE:
+		ret |= IS_FSAL_ACE_WRITE_DATA(*ace);
+		break;
+	case ACL_EXECUTE:
+		ret |= IS_FSAL_ACE_EXECUTE(*ace);
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Check whether given perm(ACL_READ, ACL_WRITE or ACL_EXECUTE) is denied for a
+ * permset, it depends on permsets of deny entry of the acl and @EVERYONE entry.
+ */
+bool
+isdeny(acl_permset_t deny, acl_permset_t everyone, acl_perm_t perm) {
 
-	if (IS_FSAL_ACE_READ_DATA(*ace))
-		acl_add_perm(*p_permset, ACL_READ);
-	if (IS_FSAL_ACE_WRITE_DATA(*ace))
-		acl_add_perm(*p_permset, ACL_WRITE);
-	if (IS_FSAL_ACE_EXECUTE(*ace))
-		acl_add_perm(*p_permset, ACL_EXECUTE);
+	return acl_get_perm(deny, perm) || acl_get_perm(everyone, perm);
 }
 
-/* delete permissions in posix acl entry according to deny ace */
-void
-convert_deny_entry_to_posix(fsal_ace_t *ace, acl_permset_t *p_permset) {
+/* Returns no of possible fsal_ace entries from a given posix_acl */
+int
+ace_count(acl_t acl) {
+	int ret;
+
+	ret = acl_entries(acl);
+	if (ret < 0)
+		return 0;
 
-	if (IS_FSAL_ACE_READ_DATA(*ace))
-		acl_delete_perm(*p_permset, ACL_READ);
-	if (IS_FSAL_ACE_WRITE_DATA(*ace))
-		acl_delete_perm(*p_permset, ACL_WRITE);
-	if (IS_FSAL_ACE_EXECUTE(*ace))
-		acl_delete_perm(*p_permset, ACL_EXECUTE);
+	/* Mask is not converted to an ace entry */
+	if (find_entry(acl, ACL_MASK, 0))
+		ret--;
+
+	return ret;
 }
 
-/* Finds ACL entry with help of tag and id */
+/*
+ * It traverse entire list of entries for a posix acl and finds ACL entry which
+ * corresponds to a given tag and id
+ *
+ * On success , it returns acl entry otherwise it returns NULL
+ */
 acl_entry_t
-find_entry(acl_t acl, acl_tag_t tag, int id) {
+find_entry(acl_t acl, acl_tag_t tag,  unsigned int id) {
 	acl_entry_t entry;
 	acl_tag_t entryTag;
 	int ent, ret;
@@ -111,7 +138,8 @@ find_entry(acl_t acl, acl_tag_t tag, int id) {
 		}
 		if (tag == entryTag) {
 			if (tag == ACL_USER || tag == ACL_GROUP)
-				if (id != *(int *)acl_get_qualifier(entry))
+				if (id != *(unsigned int *)
+						acl_get_qualifier(entry))
 					continue;
 			break;
 		}
@@ -121,16 +149,54 @@ find_entry(acl_t acl, acl_tag_t tag, int id) {
 }
 
 /*
- *  Given a POSIX ACL convert it into an equivalent FSAL ACL
+ * It tries to find out whether an entry is present in posix acl for the given
+ * (tag, id) tuple and returns it. If not , it will create a new entry for
+ * given (tag, id).
+ *
+ * On success , it returns acl entry otherwise it returns NULL
  */
-fsal_status_t
-posix_acl_2_fsal_acl(acl_t p_posixacl, fsal_acl_t **p_falacl)
+acl_entry_t
+get_entry(acl_t acl, acl_tag_t tag, unsigned int id) {
+	acl_entry_t entry;
+	int ret;
+
+	if (!acl)
+		return NULL;
+	entry = find_entry(acl, tag, id);
+
+	if (!entry) {
+		ret = acl_create_entry(&acl, &entry);
+		if (ret) {
+			LogMajor(COMPONENT_FSAL, "Cannot create entry");
+			return NULL;
+		}
+		ret = acl_set_tag_type(entry, tag);
+		if (ret)
+			LogWarn(COMPONENT_FSAL, "Cannot set tag for Entry");
+		ret = acl_set_qualifier(entry, &id);
+	}
+
+	return entry;
+}
+
+/*
+ *  @brief convert POSIX ACL into an equivalent FSAL ACL
+ *
+ * @param[in]  p_posixacl	POSIX ACL
+ * @param[in]  is_dir		Represents file/directory
+ * @param[in]  is_inherit	Represents type of ace entry
+ * @param[in]  ace		Stores the starting of fsal_acl_t
+ * @param[out] ace		Stores last ace entry in fsal_acl_t
+ *
+ * @return 0 on success and -1 on failure
+ */
+
+int
+posix_acl_2_fsal_acl(acl_t p_posixacl, bool is_dir, bool is_inherit,
+			fsal_ace_t **ace)
 {
-	int ret = 0, ent, i = 0;
-	fsal_acl_status_t status;
-	fsal_acl_data_t acldata;
+	int ret = 0, ent;
 	fsal_ace_t *pace = NULL;
-	fsal_acl_t *pacl = NULL;
 	acl_entry_t entry, mask;
 	acl_tag_t tag;
 	acl_permset_t p_permset;
@@ -139,13 +205,11 @@ posix_acl_2_fsal_acl(acl_t p_posixacl, fsal_acl_t **p_falacl)
 	bool executemask = true;
 
 	if (!p_posixacl)
-		return fsalstat(ERR_FSAL_NOENT, ret);
+		return -1;
 
-	acldata.naces = acl_entries(p_posixacl);
-
-	if (!acldata.naces)
-		return fsalstat(ERR_FSAL_NOENT, ret);
+	pace = *ace;
 
+	/* Store the mask entry values */
 	mask = find_entry(p_posixacl, ACL_MASK, 0);
 	if (mask) {
 		ret = acl_get_permset(mask, &p_permset);
@@ -158,20 +222,21 @@ posix_acl_2_fsal_acl(acl_t p_posixacl, fsal_acl_t **p_falacl)
 			writemask = false;
 		if (acl_get_perm(p_permset, ACL_EXECUTE) == 0)
 			executemask = false;
-		acldata.naces--;
 	}
 	/* *
 	 * Only ALLOW ACL Entries considered right now
 	 * TODO : How to display DENY ACL Entries
 	 * */
-	acldata.aces = (fsal_ace_t *) nfs4_ace_alloc(acldata.naces);
 
-	for (pace = acldata.aces, ent = ACL_FIRST_ENTRY;
-		i < acldata.naces; ent = ACL_NEXT_ENTRY) {
+	/*
+	 * Converts each entry in posix acl into fsal_ace by filling type, flag,
+	 * perm, iflag, flag and who(uid, gid) appropiately
+	 */
+	for (ent = ACL_FIRST_ENTRY; ; ent = ACL_NEXT_ENTRY) {
 
 		ret = acl_get_entry(p_posixacl, ent, &entry);
 		if (ret == 0 || ret == -1) {
-			LogWarn(COMPONENT_FSAL,
+			LogDebug(COMPONENT_FSAL,
 					"No more ACL entires remaining");
 			break;
 		}
@@ -179,12 +244,17 @@ posix_acl_2_fsal_acl(acl_t p_posixacl, fsal_acl_t **p_falacl)
 			LogWarn(COMPONENT_FSAL, "No entry tag for ACL Entry");
 			continue;
 		}
+
 		/* Mask is not converted to a fsal_acl entry , skipping */
 		if (tag == ACL_MASK)
 			continue;
 
 		pace->type = FSAL_ACE_TYPE_ALLOW;
-		pace->flag = 0;
+
+		if (is_inherit)
+			pace->flag = FSAL_ACE_FLAG_INHERIT;
+		else
+			pace->flag = 0;
 
 		/* Finding uid for the fsal_acl entry */
 		switch (tag) {
@@ -207,7 +277,7 @@ posix_acl_2_fsal_acl(acl_t p_posixacl, fsal_acl_t **p_falacl)
 		case  ACL_GROUP:
 			pace->who.gid =
 				*(gid_t *)acl_get_qualifier(entry);
-			pace->flag = FSAL_ACE_FLAG_GROUP_ID;
+			pace->flag |= FSAL_ACE_FLAG_GROUP_ID;
 			break;
 		default:
 			LogWarn(COMPONENT_FSAL, "Invalid tag for the acl");
@@ -220,11 +290,12 @@ posix_acl_2_fsal_acl(acl_t p_posixacl, fsal_acl_t **p_falacl)
 		 * */
 
 		/* *
-		 * Unconditionally all ALLOW ACL Entry should
-		 * have these permissions
+		 * Unconditionally all ALLOW ACL Entry should have these
+		 * permissions
 		 * */
 
 		pace->perm = FSAL_ACE_PERM_SET_DEFAULT;
+
 		ret = acl_get_permset(entry, &p_permset);
 		if (ret) {
 			LogWarn(COMPONENT_FSAL,
@@ -256,20 +327,11 @@ posix_acl_2_fsal_acl(acl_t p_posixacl, fsal_acl_t **p_falacl)
 				pace->perm = pace->perm
 						| FSAL_ACE_PERM_EXECUTE;
 		}
-		i++;
 		pace++;
 	}
-	pacl = nfs4_acl_new_entry(&acldata, &status);
-	LogMidDebug(COMPONENT_FSAL, "fsal acl = %p, fsal_acl_status = %u", pacl,
-		    status);
-	if (pacl == NULL) {
-		LogCrit(COMPONENT_FSAL,
-		"posix_acl_2_fsal_acl: failed to create a new acl entry");
-		return fsalstat(ERR_FSAL_FAULT, status);
-	} else {
-		*p_falacl = pacl;
-		return fsalstat(ERR_FSAL_NO_ERROR, ret);
-	}
+
+        *ace = pace;
+        return 0;
 }
 
 /*
@@ -278,160 +340,71 @@ posix_acl_2_fsal_acl(acl_t p_posixacl, fsal_acl_t **p_falacl)
 acl_t
 fsal_acl_2_posix_acl(fsal_acl_t *p_fsalacl, acl_type_t type)
 {
-	int ret = 0, i, u_count = 0, g_count = 0, entries = 0;
-	int d_user = 0, d_group = 0;
-	fsal_ace_t *f_ace, *deny_ace = NULL;
-	acl_t p_acl, dummy_acl;
-	acl_entry_t p_entry, everyone;
-	acl_permset_t p_permset, e_permset;
-	/* FIXME : The no of users/groups is limited to hundred here */
-	uid_t uid[100], tmp_uid;
-	gid_t gid[100], tmp_gid;
-	bool user = false;
-	bool group = false;
-	bool dup_entry = false;
-
-	if (p_fsalacl == NULL)
+	int ret = 0, i;
+	fsal_ace_t *f_ace;
+	acl_t allow_acl, deny_acl;
+	acl_entry_t a_entry, d_entry;
+	acl_permset_t a_permset, e_a_permset, d_permset, e_d_permset;
+	acl_tag_t tag;
+	char *acl_str;
+	unsigned int id;
+	bool mask = false;
+	bool deny_e_r = false, deny_e_w = false, deny_e_x = false;
+
+	if (p_fsalacl == NULL || p_fsalacl->naces < 0)
 		return NULL;
-	/*
-	 * Calculating no of default entries and access entries
-	 * in the given fsal_acl
-	 */
-	switch (type) {
-	case ACL_TYPE_ACCESS:
-		for (f_ace = p_fsalacl->aces;
-			f_ace < p_fsalacl->aces + p_fsalacl->naces; f_ace++) {
-			if (is_ace_valid_for_effective_acl_entry(f_ace))
-				entries++;
-		}
-		break;
-	case ACL_TYPE_DEFAULT:
+
+	/* *
+	 * Check whether ace list contains any inherited entries, if not then
+	 * returns NULL.
+	 * */
+	if (type == ACL_TYPE_DEFAULT) {
 		for (f_ace = p_fsalacl->aces;
 			f_ace < p_fsalacl->aces + p_fsalacl->naces; f_ace++) {
 			if (is_ace_valid_for_inherited_acl_entry(f_ace))
-				entries++;
+				ret++;
 		}
-		break;
-	default:
-		LogWarn(COMPONENT_FSAL, "Invalid type for the acl");
+		if (ret == 0)
+			return NULL;
 	}
 
-	if (entries == 0)
-		return NULL;
-
 	/*
-	 * The given fsal_acl list may not contains all required entries
-	 * (OWNER@, @GROUP, @EVERYONE) so for a safer approach we may
-	 * allocate three more than required. This problem may occur more
-	 * prominently inherit acl
+	 * FIXME: Always allocating with maximum possible value of acl entries,
+	 * there is a possibility of memory leak
 	 */
-	p_acl = acl_init(entries + 3);
+	allow_acl = acl_init(p_fsalacl->naces + 1);
+	deny_acl = acl_init(p_fsalacl->naces + 1);
 
-	/* To store values of EVERYONE ACE, a duumy acl entry is used and
-	 * it freed at the end */
-	dummy_acl = acl_init(1);
-	ret = acl_create_entry(&dummy_acl, &everyone);
+	/* first convert ACE EVERYONE@ to ACL_OTHER */
+	ret = acl_create_entry(&allow_acl, &a_entry);
 	if (ret) {
 		LogMajor(COMPONENT_FSAL, "Cannot create entry for other");
 		return NULL;
 	}
-	ret = acl_set_tag_type(everyone, ACL_OTHER);
+	ret = acl_set_tag_type(a_entry, ACL_OTHER);
 	if (ret)
 		LogWarn(COMPONENT_FSAL, "Cannot set tag for ACL Entry");
 
-	ret = acl_get_permset(everyone, &e_permset);
-	for (f_ace = p_fsalacl->aces;
-		f_ace < p_fsalacl->aces + p_fsalacl->naces; f_ace++) {
-			if (IS_FSAL_ACE_SPECIAL_EVERYONE(*f_ace)) {
-				if ((type == ACL_TYPE_ACCESS &&
-				!is_ace_valid_for_effective_acl_entry(f_ace))
-				|| (type == ACL_TYPE_DEFAULT &&
-				!is_ace_valid_for_inherited_acl_entry(f_ace)))
-					continue;
-				if (IS_FSAL_ACE_DENY(*f_ace))
-					deny_ace = f_ace;
-				else if (IS_FSAL_ACE_ALLOW(*f_ace))
-					convert_allow_entry_to_posix(f_ace,
-								&e_permset);
-			}
-	}
 
-	if (deny_ace) {
-		convert_deny_entry_to_posix(deny_ace, &e_permset);
-		deny_ace = NULL;
-	}
-	/*
-	 * Populating list of users and group which are not special.
-	 * Mulitple entries for same users and group is possible, so
-	 * avoid duplicate entries in the array.
-	 * TODO: Use a separate api for performing this function
-	 * Annoymous users/groups (id = -1) should handle properly
-	 */
-	for (f_ace = p_fsalacl->aces;
-	f_ace < p_fsalacl->aces + p_fsalacl->naces; f_ace++) {
-		if (!IS_FSAL_ACE_SPECIAL_ID(*f_ace)) {
-			if (IS_FSAL_ACE_GROUP_ID(*f_ace)) {
-				tmp_gid = GET_FSAL_ACE_WHO(*f_ace);
-				for (i = 0; i < g_count ; i++) {
-					if (gid[i] == tmp_gid) {
-						dup_entry = true;
-						break;
-					}
-				}
-				if (dup_entry) {
-					dup_entry = false;
-					continue;
-				}
-				gid[g_count++] = tmp_gid;
-			} else {
-				tmp_uid = GET_FSAL_ACE_WHO(*f_ace);
-				for (i = 0; i < u_count ; i++) {
-					if (uid[i] == tmp_uid) {
-						dup_entry = true;
-						break;
-					}
-				}
-				if (dup_entry) {
-					dup_entry = false;
-					continue;
-				}
-				uid[u_count++] = tmp_uid;
-			}
-		}
-	}
-	if (u_count > 0)
-		user = true;
-	if (g_count > 0)
-		group = true;
+	ret = acl_get_permset(a_entry, &e_a_permset);
+
 
-	LogDebug(COMPONENT_FSAL, "u_count = %d g_count = %d entries = %d",
-		       u_count, g_count, entries);
 	/*
-	 * The fsal_acl list is unordered, but we need to keep posix_acl in
-	 * a specific order such that users, groups, other.So we will fetch
-	 * ACE's from the fsal_acl in that order and convert it into a
-	 * corresponding posix_acl entry
-	 *
-	 * TODO: Currently there are lots of code duplication in this api
-	 *       So its better implement different api's for :
-	 *             1.) fetching a required ACE from fsal_acl
-	 *             2.) Convert a ACE into corresponding posix_acl_entry
-	 *	and use them
+	 * Deny entry for @EVERYONE created only because it will ease the
+	 * manipulation of other acl entries. It will be updated only when deny
+	 * entry for @EVERYONE is encountered
 	 */
 
-	ret = acl_create_entry(&p_acl, &p_entry);
-	if (ret) {
-		LogMajor(COMPONENT_FSAL, "Cannot create entry for user");
-		return NULL;
-	}
+	ret = acl_create_entry(&deny_acl, &d_entry);
+	if (ret)
+		LogMajor(COMPONENT_FSAL, "Cannot create entry for other");
 
-	ret = acl_set_tag_type(p_entry, ACL_USER_OBJ);
+	ret = acl_set_tag_type(d_entry, ACL_OTHER);
 	if (ret)
-		LogWarn(COMPONENT_FSAL, "Cannot set tag for Entry");
+		LogWarn(COMPONENT_FSAL, "Cannot set tag for ACL Entry");
 
-	ret = acl_get_permset(p_entry, &p_permset);
+	ret = acl_get_permset(d_entry, &e_d_permset);
 
-	/* Deny entry is handled at the end */
 	for (f_ace = p_fsalacl->aces;
 		f_ace < p_fsalacl->aces + p_fsalacl->naces; f_ace++) {
 			if ((type == ACL_TYPE_ACCESS &&
@@ -440,491 +413,156 @@ fsal_acl_2_posix_acl(fsal_acl_t *p_fsalacl, acl_type_t type)
 			!is_ace_valid_for_inherited_acl_entry(f_ace)))
 				continue;
 
-			if (IS_FSAL_ACE_SPECIAL_OWNER(*f_ace)) {
-				if (IS_FSAL_ACE_DENY(*f_ace))
-					deny_ace = f_ace;
-				else if (IS_FSAL_ACE_ALLOW(*f_ace))
-					convert_allow_entry_to_posix(f_ace,
-								&p_permset);
+			if (IS_FSAL_ACE_DENY(*f_ace)) {
+				if (IS_FSAL_ACE_READ_DATA(*f_ace))
+					deny_e_r = true;
+				if (IS_FSAL_ACE_WRITE_DATA(*f_ace))
+					deny_e_w = true;
+				if (IS_FSAL_ACE_EXECUTE(*f_ace))
+					deny_e_x = true;
+			} else if (IS_FSAL_ACE_ALLOW(*f_ace)) {
+				if (IS_FSAL_ACE_READ_DATA(*f_ace) && !deny_e_r)
+					acl_add_perm(e_a_permset, ACL_READ);
+				if (IS_FSAL_ACE_WRITE_DATA(*f_ace) && !deny_e_w)
+					acl_add_perm(e_a_permset, ACL_WRITE);
+				if (IS_FSAL_ACE_EXECUTE(*f_ace) && !deny_e_x)
+					acl_add_perm(e_a_permset, ACL_EXECUTE);
 			}
 	}
 
-	/* Adding everyone's permission to the permset, if it is applicable */
-	if (acl_get_perm(e_permset, ACL_READ))
-		acl_add_perm(p_permset, ACL_READ);
-	if (acl_get_perm(e_permset, ACL_WRITE))
-		acl_add_perm(p_permset, ACL_WRITE);
-	if (acl_get_perm(e_permset, ACL_EXECUTE))
-		acl_add_perm(p_permset, ACL_EXECUTE);
-
-	if (deny_ace) {
-		convert_deny_entry_to_posix(deny_ace, &p_permset);
-		deny_ace = NULL;
+	/*
+	 * It is mandatory to have acl entries for ACL_USER_OBJ and
+	 * ACL_GROUP_OBJ
+	 */
+	ret = acl_create_entry(&allow_acl, &a_entry);
+	if (ret) {
+		LogMajor(COMPONENT_FSAL, "Cannot create entry for other");
+		return NULL;
 	}
+	ret = acl_set_tag_type(a_entry, ACL_USER_OBJ);
+	if (ret)
+		LogWarn(COMPONENT_FSAL, "Cannot set tag for ACL Entry");
 
-	if (user) {
-		for (i = 0; i < u_count; i++) {
-			ret = acl_create_entry(&p_acl, &p_entry);
-			if (ret)
-				LogWarn(COMPONENT_FSAL,
-					"Cannot create entry for user id %d",
-					uid[i]);
-			ret = acl_set_tag_type(p_entry, ACL_USER);
-			if (ret)
-				LogWarn(COMPONENT_FSAL,
-					"Cannot set tag for ACL Entry");
-
-			ret = acl_set_qualifier(p_entry, &uid[i]);
-
-			ret = acl_get_permset(p_entry, &p_permset);
-			for (f_ace = p_fsalacl->aces;
-			f_ace < p_fsalacl->aces + p_fsalacl->naces; f_ace++) {
-				if (IS_FSAL_ACE_USER(*f_ace, uid[i])) {
-					if ((type == ACL_TYPE_ACCESS &&
-					!is_ace_valid_for_effective_acl_entry(
-									f_ace))
-					|| (type == ACL_TYPE_DEFAULT &&
-					!is_ace_valid_for_inherited_acl_entry(
-									f_ace)))
-						continue;
-
-					if (IS_FSAL_ACE_DENY(*f_ace))
-						deny_ace = f_ace;
-					else if (IS_FSAL_ACE_ALLOW(*f_ace))
-						convert_allow_entry_to_posix(
-							f_ace, &p_permset);
-				}
-			}
-
-			/* Adding everyone's permission to the permset,
-			 * if it is applicable
-			 */
-			if (acl_get_perm(e_permset, ACL_READ))
-				acl_add_perm(p_permset, ACL_READ);
-			if (acl_get_perm(e_permset, ACL_WRITE))
-				acl_add_perm(p_permset, ACL_WRITE);
-			if (acl_get_perm(e_permset, ACL_EXECUTE))
-				acl_add_perm(p_permset, ACL_EXECUTE);
-
-			if (deny_ace) {
-				convert_deny_entry_to_posix(deny_ace,
-								 &p_permset);
-				deny_ace = NULL;
-			}
-			if (!acl_get_perm(p_permset, ACL_READ)
-				&& !acl_get_perm(p_permset, ACL_WRITE)
-				&& !acl_get_perm(p_permset, ACL_EXECUTE)) {
-				acl_delete_entry(p_acl, p_entry);
-				d_user++;
-			}
-		}
-	}
-	ret = acl_create_entry(&p_acl, &p_entry);
+	ret = acl_create_entry(&allow_acl, &a_entry);
 	if (ret) {
-		LogMajor(COMPONENT_FSAL, "Cannot create entry for group");
+		LogMajor(COMPONENT_FSAL, "Cannot create entry for other");
 		return NULL;
 	}
 
-	ret = acl_set_tag_type(p_entry, ACL_GROUP_OBJ);
+	ret = acl_set_tag_type(a_entry, ACL_GROUP_OBJ);
 	if (ret)
 		LogWarn(COMPONENT_FSAL, "Cannot set tag for ACL Entry");
-	ret = acl_get_permset(p_entry, &p_permset);
 
+	/*
+	 * TODO: Annoymous users/groups (id = -1) should handle properly
+	 */
+
+	/*
+	 * It uses two posix acl - allow_acl and deny_acl which represents ALLOW
+	 * and DENY aces respectively. They are filled according to the order in
+	 * fsal_acl list. The allow acl is build based on ALLOW ace, @EVERYONE
+	 * ace and deny acl. The permset for allow acl entry is constructed in
+	 * such a way that it will contain all permissions(READ,WRITE,EXECUTE)
+	 * of ALLOW aces plus EVERYONE which is not denied by the corresponding
+	 * deny acl entry
+	 *
+	 * At last allow_acl is returned and deny_acl is ignored.
+	 */
 	for (f_ace = p_fsalacl->aces;
 		f_ace < p_fsalacl->aces + p_fsalacl->naces; f_ace++) {
-			if (IS_FSAL_ACE_SPECIAL_GROUP(*f_ace)) {
-				if ((type == ACL_TYPE_ACCESS &&
-				!is_ace_valid_for_effective_acl_entry(f_ace))
-				|| (type == ACL_TYPE_DEFAULT &&
-				!is_ace_valid_for_inherited_acl_entry(f_ace)))
-					continue;
-
-				if (IS_FSAL_ACE_DENY(*f_ace))
-					deny_ace = f_ace;
-				else if (IS_FSAL_ACE_ALLOW(*f_ace))
-					convert_allow_entry_to_posix(f_ace,
-								&p_permset);
+			if ((type == ACL_TYPE_ACCESS &&
+			!is_ace_valid_for_effective_acl_entry(f_ace))
+			|| (type == ACL_TYPE_DEFAULT &&
+			!is_ace_valid_for_inherited_acl_entry(f_ace)))
+				continue;
+			if (IS_FSAL_ACE_SPECIAL_ID(*f_ace)) {
+				id = 0;
+				if (IS_FSAL_ACE_SPECIAL_OWNER(*f_ace))
+					tag = ACL_USER_OBJ;
+				if (IS_FSAL_ACE_SPECIAL_GROUP(*f_ace))
+					tag = ACL_GROUP_OBJ;
+			} else {
+				id = GET_FSAL_ACE_WHO(*f_ace);
+				if (IS_FSAL_ACE_GROUP_ID(*f_ace))
+					tag = ACL_GROUP;
+				else
+					tag = ACL_USER;
+				/*
+				 * Mask entry will be created only if it
+				 * contains user or group entry
+				 */
+				mask = true;
 			}
-	}
-
-	/* Adding everyone's permission to the permset, if it is applicable */
-	if (acl_get_perm(e_permset, ACL_READ))
-		acl_add_perm(p_permset, ACL_READ);
-	if (acl_get_perm(e_permset, ACL_WRITE))
-		acl_add_perm(p_permset, ACL_WRITE);
-	if (acl_get_perm(e_permset, ACL_EXECUTE))
-		acl_add_perm(p_permset, ACL_EXECUTE);
-
-	if (deny_ace) {
-		convert_deny_entry_to_posix(deny_ace, &p_permset);
-		deny_ace = NULL;
-	}
-
-	if (group) {
-		for (i = 0; i < g_count; i++) {
-			ret = acl_create_entry(&p_acl, &p_entry);
-			if (ret)
-				LogWarn(COMPONENT_FSAL,
-				"Cannot create entry for group id %d",
-				gid[i]);
-
-			ret = acl_set_tag_type(p_entry, ACL_GROUP);
-			if (ret)
-				LogWarn(COMPONENT_FSAL,
-				      "Cannot set tag for ACL Entry");
-
-			ret = acl_set_qualifier(p_entry, &gid[i]);
-
-			ret = acl_get_permset(p_entry, &p_permset);
-			for (f_ace = p_fsalacl->aces;
-			f_ace < p_fsalacl->aces + p_fsalacl->naces; f_ace++) {
-				if (IS_FSAL_ACE_GROUP(*f_ace, gid[i])) {
-					if ((type == ACL_TYPE_ACCESS &&
-					!is_ace_valid_for_effective_acl_entry(
-									f_ace))
-					|| (type == ACL_TYPE_DEFAULT &&
-					!is_ace_valid_for_inherited_acl_entry(
-									f_ace)))
-						continue;
-
-				if (IS_FSAL_ACE_DENY(*f_ace))
-					deny_ace = f_ace;
-				else if (IS_FSAL_ACE_ALLOW(*f_ace))
-					convert_allow_entry_to_posix(
-							f_ace, &p_permset);
+			if (IS_FSAL_ACE_SPECIAL_EVERYONE(*f_ace)) {
+				if (IS_FSAL_ACE_DENY(*f_ace)) {
+					if (deny_e_r)
+						acl_add_perm(e_d_permset,
+								ACL_READ);
+					if (deny_e_w)
+						acl_add_perm(e_d_permset,
+								ACL_WRITE);
+					if (deny_e_x)
+						acl_add_perm(e_d_permset,
+								ACL_EXECUTE);
 				}
+				continue;
 			}
 
-			/* Adding everyone's permission to the permset,
-			 *  if it is applicable
-			 */
-			if (acl_get_perm(e_permset, ACL_READ))
-				acl_add_perm(p_permset, ACL_READ);
-			if (acl_get_perm(e_permset, ACL_WRITE))
-				acl_add_perm(p_permset, ACL_WRITE);
-			if (acl_get_perm(e_permset, ACL_EXECUTE))
-				acl_add_perm(p_permset, ACL_EXECUTE);
-
-			if (deny_ace) {
-				convert_deny_entry_to_posix(deny_ace,
-								 &p_permset);
-				deny_ace = NULL;
+			a_entry = get_entry(allow_acl, tag, id);
+			d_entry = get_entry(deny_acl, tag, id);
+			ret = acl_get_permset(d_entry, &d_permset);
+
+			if (IS_FSAL_ACE_DENY(*f_ace)) {
+				if (IS_FSAL_ACE_READ_DATA(*f_ace))
+					acl_add_perm(d_permset, ACL_READ);
+				if (IS_FSAL_ACE_WRITE_DATA(*f_ace))
+					acl_add_perm(d_permset, ACL_WRITE);
+				if (IS_FSAL_ACE_EXECUTE(*f_ace))
+					acl_add_perm(d_permset, ACL_EXECUTE);
 			}
-			if (!acl_get_perm(p_permset, ACL_READ)
-				&& !acl_get_perm(p_permset, ACL_WRITE)
-				&& !acl_get_perm(p_permset, ACL_EXECUTE)) {
-					acl_delete_entry(p_acl, p_entry);
-					d_group++;
+			if (IS_FSAL_ACE_ALLOW(*f_ace)) {
+				ret = acl_get_permset(a_entry, &a_permset);
+				if (isallow(f_ace, e_a_permset, ACL_READ)
+				&& !isdeny(d_permset, e_d_permset, ACL_READ))
+					acl_add_perm(a_permset, ACL_READ);
+
+				if (isallow(f_ace, e_a_permset, ACL_WRITE)
+				&& !isdeny(d_permset, e_d_permset, ACL_WRITE))
+					acl_add_perm(a_permset, ACL_WRITE);
+
+				if (isallow(f_ace, e_a_permset, ACL_EXECUTE)
+				&& !isdeny(d_permset, e_d_permset, ACL_EXECUTE))
+					acl_add_perm(a_permset, ACL_EXECUTE);
 			}
-		}
-	}
-	ret = acl_create_entry(&p_acl, &p_entry);
-	if (ret) {
-		LogMajor(COMPONENT_FSAL, "Cannot create entry for other");
-		return NULL;
 	}
-	acl_copy_entry(p_entry, everyone);
-
-	/* calculate appropriate mask if it is needed*/
-	if ((u_count - d_user) > 0 || (g_count - d_group) > 0) {
-		ret = acl_calc_mask(&p_acl);
+	if (mask) {
+		ret = acl_calc_mask(&allow_acl);
 		if (ret)
 			LogWarn(COMPONENT_FSAL,
 			"Cannot calculate mask for posix");
 	}
 
-	/* A valid acl_t should have only one entry for
-	 * ACL_USER_OBJ, ACL_GROUP_OBJ, ACL_OTHER and
-	 * ACL_MASK is required only if ACL_USER or
-	 * ACL_GROUP exists
+	/* A valid acl_t should have only one entry for ACL_USER_OBJ,
+	 * ACL_GROUP_OBJ, ACL_OTHER and ACL_MASK is required only if
+	 * ACL_USER or ACL_GROUP exists
 	 */
-	ret = acl_check(p_acl, &i);
+	ret = acl_check(allow_acl, &i);
 	if (ret) {
 		if (ret > 0) {
 			LogWarn(COMPONENT_FSAL,
-			"Error converting ACL: %s at entry no %d",
-			acl_error(ret), i);
-		}
-		return NULL;
-
-	}
-	LogDebug(COMPONENT_FSAL, "posix acl = %s ",
-				acl_to_any_text(p_acl, NULL, ',',
-					TEXT_ABBREVIATE |
-					TEXT_NUMERIC_IDS));
-	acl_free(dummy_acl);
-	return p_acl;
-}
-
-/*
- *  Given a Posix ACL for directory convert it into an equivalent FSAL ACL
- */
-fsal_status_t
-posix_acl_2_fsal_acl_for_dir(acl_t e_acl, acl_t i_acl, fsal_acl_t **p_falacl)
-{
-	/* *
-	 * TODO : This api uses same logic as the fsal_acl_2_posix_acl ,
-	 * so it will be better to club both api's together
-	 */
-	int ret = 0, ent, i = 0, ni = 0, ne = 0;
-	fsal_acl_status_t status;
-	fsal_acl_data_t acldata;
-	fsal_ace_t *pace = NULL;
-	fsal_acl_t *pacl = NULL;
-	acl_entry_t entry, e_mask, i_mask;
-	acl_tag_t tag;
-	acl_permset_t p_permset;
-	bool e_readmask = true;
-	bool e_writemask = true;
-	bool e_executemask = true;
-	bool i_readmask = true;
-	bool i_writemask = true;
-	bool i_executemask = true;
-
-	if (!e_acl)
-		return fsalstat(ERR_FSAL_NOENT, ret);
-	/* *
-	 * Here both effective acl and default acl need to be converted,
-	 * then store it fsal acl, order for ACE entries doesnot matter
-	 */
-	ne = acl_entries(e_acl);
-	ni = acl_entries(i_acl);
-
-	e_mask = find_entry(e_acl, ACL_MASK, 0);
-	if (e_mask) {
-		ret = acl_get_permset(e_mask, &p_permset);
-		if (ret)
-			LogWarn(COMPONENT_FSAL,
-			"Cannot retrieve permission set for the Mask Entry");
-		if (acl_get_perm(p_permset, ACL_READ) == 0)
-			e_readmask = false;
-		if (acl_get_perm(p_permset, ACL_WRITE) == 0)
-			e_writemask = false;
-		if (acl_get_perm(p_permset, ACL_EXECUTE) == 0)
-			e_executemask = false;
-		ne--;
-	}
-	i_mask = find_entry(i_acl, ACL_MASK, 0);
-	if (i_mask) {
-		ret = acl_get_permset(i_mask, &p_permset);
-		if (ret)
-			LogWarn(COMPONENT_FSAL,
-			"Cannot retrieve permission set for the Mask Entry");
-		if (acl_get_perm(p_permset, ACL_READ) == 0)
-			i_readmask = false;
-		if (acl_get_perm(p_permset, ACL_WRITE) == 0)
-			i_writemask = false;
-		if (acl_get_perm(p_permset, ACL_EXECUTE) == 0)
-			i_executemask = false;
-		ni--;
-	}
-
-	acldata.naces = ne + ni;
-	if (!acldata.naces)
-		return fsalstat(ERR_FSAL_NOENT, ret);
-
-	acldata.aces = (fsal_ace_t *) nfs4_ace_alloc(acldata.naces);
-
-	/* Converting effective acl entry */
-	for (pace = acldata.aces, ent = ACL_FIRST_ENTRY; i < ne;
-			ent = ACL_NEXT_ENTRY) {
-
-		ret = acl_get_entry(e_acl, ent, &entry);
-		if (ret == 0 || ret == -1) {
-			LogWarn(COMPONENT_FSAL,
-					"No more ACL entires remaining ");
-			break;
+				"Error converting ACL: %s at entry no %d",
+				acl_error(ret), i);
 		}
-		if (acl_get_tag_type(entry, &tag) == -1) {
-			LogWarn(COMPONENT_FSAL, "No entry tag for ACL Entry");
-			continue;
-		}
-		/* Mask is not converted to a fsal_acl entry , skipping */
-		if (tag == ACL_MASK)
-			continue;
 
-		pace->type = FSAL_ACE_TYPE_ALLOW;
-		pace->flag = 0;
-
-		/* Finding uid for the fsal_acl entry */
-		switch (tag) {
-		case  ACL_USER_OBJ:
-			pace->who.uid =  FSAL_ACE_SPECIAL_OWNER;
-			pace->iflag = FSAL_ACE_IFLAG_SPECIAL_ID;
-			break;
-		case  ACL_GROUP_OBJ:
-			pace->who.uid =  FSAL_ACE_SPECIAL_GROUP;
-			pace->iflag = FSAL_ACE_IFLAG_SPECIAL_ID;
-			break;
-		case  ACL_OTHER:
-			pace->who.uid =  FSAL_ACE_SPECIAL_EVERYONE;
-			pace->iflag = FSAL_ACE_IFLAG_SPECIAL_ID;
-			break;
-		case  ACL_USER:
-			pace->who.uid =
-				*(uid_t *)acl_get_qualifier(entry);
-			break;
-		case  ACL_GROUP:
-			pace->who.gid =
-				*(gid_t *)acl_get_qualifier(entry);
-			pace->flag = FSAL_ACE_FLAG_GROUP_ID;
-			break;
-		default:
-			LogWarn(COMPONENT_FSAL, "Invalid tag for the acl");
-		}
-
-		/* *
-		 * Finding permission set for the fsal_acl entry.
-		 * Conversion purely is based on
-		 * http://tools.ietf.org/html/draft-ietf-nfsv4-acl-mapping-05
-		 * */
-
-		/* *
-		 * Unconditionally all ALLOW ACL Entry should
-		 * have these permissions
-		 * */
-
-		pace->perm = FSAL_ACE_PERM_SET_DEFAULT;
-		ret = acl_get_permset(entry, &p_permset);
-		if (ret) {
-			LogWarn(COMPONENT_FSAL,
-			"Cannot retrieve permission set for the ACL Entry");
-			continue;
-		}
-		/* *
-		 * Consider Mask bits only for ACL_USER, ACL_GROUP,
-		 * ACL_GROUP_OBJ entries
-		 * */
-		if (acl_get_perm(p_permset, ACL_READ)) {
-			if (tag == ACL_USER_OBJ || tag == ACL_OTHER ||
-						e_readmask)
-				pace->perm = pace->perm
-						| FSAL_ACE_PERM_READ_DATA;
-		}
-		if (acl_get_perm(p_permset, ACL_WRITE)) {
-			if (tag == ACL_USER_OBJ || tag == ACL_OTHER ||
-						e_writemask)
-				pace->perm = pace->perm
-					| FSAL_ACE_PERM_SET_DEFAULT_WRITE_DIR;
-			if (tag == ACL_USER_OBJ)
-				pace->perm = pace->perm
-						| FSAL_ACE_PERM_SET_OWNER_WRITE;
-		}
-		if (acl_get_perm(p_permset, ACL_EXECUTE)) {
-			if (tag == ACL_USER_OBJ || tag == ACL_OTHER ||
-						e_executemask)
-				pace->perm = pace->perm
-						| FSAL_ACE_PERM_EXECUTE;
-		}
-		i++;
-		pace++;
 	}
 
-	/*
-	 * Converting inherited acl entry ,here flags should be set
-	 * correspondingly
-	 */
-	for (i = 0, ent = ACL_FIRST_ENTRY; i < ni; ent = ACL_NEXT_ENTRY) {
-
-		ret = acl_get_entry(i_acl, ent, &entry);
-		if (ret == 0 || ret == -1) {
-			LogWarn(COMPONENT_FSAL,
-					"No more ACL entires remaining ");
-			break;
-		}
-		if (acl_get_tag_type(entry, &tag) == -1) {
-			LogWarn(COMPONENT_FSAL, "No entry tag for ACL Entry");
-			continue;
-		}
-		/* Mask is not converted to a fsal_acl entry , skipping */
-		if (tag == ACL_MASK)
-			continue;
-
-		pace->type = FSAL_ACE_TYPE_ALLOW;
-		pace->flag = FSAL_ACE_FLAG_INHERIT;
-
-		/* Finding uid for the fsal_acl entry */
-		switch (tag) {
-		case  ACL_USER_OBJ:
-			pace->who.uid =  FSAL_ACE_SPECIAL_OWNER;
-			pace->iflag = FSAL_ACE_IFLAG_SPECIAL_ID;
-			break;
-		case  ACL_GROUP_OBJ:
-			pace->who.uid =  FSAL_ACE_SPECIAL_GROUP;
-			pace->iflag = FSAL_ACE_IFLAG_SPECIAL_ID;
-			break;
-		case  ACL_OTHER:
-			pace->who.uid =  FSAL_ACE_SPECIAL_EVERYONE;
-			pace->iflag = FSAL_ACE_IFLAG_SPECIAL_ID;
-			break;
-		case  ACL_USER:
-			pace->who.uid =
-				*(uid_t *)acl_get_qualifier(entry);
-			break;
-		case  ACL_GROUP:
-			pace->who.gid =
-				*(gid_t *)acl_get_qualifier(entry);
-			pace->flag |= FSAL_ACE_FLAG_GROUP_ID;
-			break;
-		default:
-			LogWarn(COMPONENT_FSAL, "Invalid tag for the acl");
-		}
-
-		/* *
-		 * Finding permission set for the fsal_acl entry.
-		 * Conversion purely is based on
-		 * http://tools.ietf.org/html/draft-ietf-nfsv4-acl-mapping-05
-		 * */
+	acl_str = acl_to_any_text(allow_acl, NULL, ',',
+				TEXT_ABBREVIATE | TEXT_NUMERIC_IDS);
+	LogDebug(COMPONENT_FSAL, "posix acl = %s ", acl_str);
 
-		/* *
-		 * Unconditionally all ALLOW ACL Entry should
-		 * have these permissions
-		 * */
+	acl_free(acl_str);
+	if (deny_acl)
+		acl_free(deny_acl);
 
-		pace->perm = FSAL_ACE_PERM_SET_DEFAULT;
-		ret = acl_get_permset(entry, &p_permset);
-		if (ret) {
-			LogWarn(COMPONENT_FSAL,
-			"Cannot retrieve permission set for the ACL Entry");
-			continue;
-		}
-		/* *
-		 * Consider Mask bits only for ACL_USER, ACL_GROUP,
-		 * ACL_GROUP_OBJ entries
-		 * */
-		if (acl_get_perm(p_permset, ACL_READ)) {
-			if (tag == ACL_USER_OBJ || tag == ACL_OTHER ||
-						i_readmask)
-				pace->perm = pace->perm
-						| FSAL_ACE_PERM_READ_DATA;
-		}
-		if (acl_get_perm(p_permset, ACL_WRITE)) {
-			if (tag == ACL_USER_OBJ || tag == ACL_OTHER ||
-						i_writemask)
-				pace->perm = pace->perm
-					| FSAL_ACE_PERM_SET_DEFAULT_WRITE_DIR;
-			if (tag == ACL_USER_OBJ)
-				pace->perm = pace->perm
-						| FSAL_ACE_PERM_SET_OWNER_WRITE;
-		}
-		if (acl_get_perm(p_permset, ACL_EXECUTE)) {
-			if (tag == ACL_USER_OBJ || tag == ACL_OTHER ||
-						i_executemask)
-				pace->perm = pace->perm
-						| FSAL_ACE_PERM_EXECUTE;
-		}
-		i++;
-		pace++;
-	}
-	pacl = nfs4_acl_new_entry(&acldata, &status);
-	LogMidDebug(COMPONENT_FSAL, "fsal acl = %p, fsal_acl_status = %u", pacl,
-		    status);
-	if (pacl == NULL) {
-		LogCrit(COMPONENT_FSAL,
-		"posix_acl_2_fsal_acl_for_dir: failed to create a new acl entry");
-		return fsalstat(ERR_FSAL_FAULT, status);
-	} else {
-		*p_falacl = pacl;
-		return fsalstat(ERR_FSAL_NO_ERROR, ret);
-	}
+	return allow_acl;
 }
diff --git a/src/FSAL/FSAL_GLUSTER/posix_acls.h b/src/FSAL/FSAL_GLUSTER/posix_acls.h
index 3e70a89..df70bfd 100644
--- a/src/FSAL/FSAL_GLUSTER/posix_acls.h
+++ b/src/FSAL/FSAL_GLUSTER/posix_acls.h
@@ -1,5 +1,6 @@
 #include <sys/acl.h>
-
+#include "nfs4_acls.h"
+#include <acl/libacl.h>
 #include "fsal_types.h"
 
 /* inheritance flags checks */
@@ -23,18 +24,19 @@
 	(FSAL_ACE_PERM_WRITE_DATA | FSAL_ACE_PERM_APPEND_DATA)
 #define FSAL_ACE_PERM_SET_OWNER_WRITE \
 	(FSAL_ACE_PERM_WRITE_ACL | FSAL_ACE_PERM_WRITE_ATTR)
-#define FSAL_ACE_PERM_SET_DEFAULT_WRITE_DIR \
-	(FSAL_ACE_PERM_WRITE_DATA | FSAL_ACE_PERM_APPEND_DATA \
-	| FSAL_ACE_PERM_DELETE_CHILD)
 
-fsal_status_t
-posix_acl_2_fsal_acl(acl_t p_posixacl, fsal_acl_t **p_falacl);
+int
+posix_acl_2_fsal_acl(acl_t p_posixacl, bool is_dir, bool is_inherit,
+			fsal_ace_t **p_falacl);
 
 acl_t
 fsal_acl_2_posix_acl(fsal_acl_t *p_fsalacl, acl_type_t type);
 
 acl_entry_t
-find_entry(acl_t acl, acl_tag_t tag, int id);
+find_entry(acl_t acl, acl_tag_t tag, unsigned int id);
+
+acl_entry_t
+get_entry(acl_t acl, acl_tag_t tag, unsigned int id);
 
-fsal_status_t
-posix_acl_2_fsal_acl_for_dir(acl_t e_acl, acl_t i_acl, fsal_acl_t **p_falacl);
+int
+ace_count(acl_t acl);
-- 
2.1.0

