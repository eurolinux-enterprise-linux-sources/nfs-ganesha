From 792ce09acb327c77605511c304cd5cbc7b28ea8d Mon Sep 17 00:00:00 2001
From: Daniel Gryniewicz <dang@redhat.com>
Date: Wed, 4 Jan 2017 14:32:19 -0500
Subject: [PATCH] State - Take a ref on an object for each state

The state is linked into the list in the state_hdl.  For MDCACHE, this
lives directly in the entry itself.  This means that, if the entry is
reused, this list get's cleaned and reused.  The new entry can then be
freed, and when the old state is removed, it derefences into the now
freed entry, causing use-after-free.

Take a ref on the entry for each state; this will keep the entry from
being reused off the LRU.

Change-Id: I8d810c2cb884450c08620096f77d08fe70255d8d
Signed-off-by: Daniel Gryniewicz <dang@redhat.com>
---
 src/SAL/nfs4_state.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/SAL/nfs4_state.c b/src/SAL/nfs4_state.c
index 88bdf70..c968fad 100644
--- a/src/SAL/nfs4_state.c
+++ b/src/SAL/nfs4_state.c
@@ -202,6 +202,8 @@ state_status_t state_add_impl(struct fsal_obj_handle *obj,
 	/* Add state to list for file */
 	PTHREAD_MUTEX_lock(&pnew_state->state_mutex);
 	glist_add_tail(&ostate->file.list_of_states, &pnew_state->state_list);
+	/* Get ref for this state entry */
+	obj->obj_ops.get_ref(obj);
 	PTHREAD_MUTEX_unlock(&pnew_state->state_mutex);
 
 	/* Add state to list for owner */
@@ -371,6 +373,8 @@ void state_del_locked(state_t *state)
 	/* Remove from the list of states for a particular file */
 	PTHREAD_MUTEX_lock(&state->state_mutex);
 	glist_del(&state->state_list);
+	/* Put ref for this state entry */
+	obj->obj_ops.put_ref(obj);
 	memset(&state->state_obj, 0, sizeof(state->state_obj));
 	PTHREAD_MUTEX_unlock(&state->state_mutex);
 
-- 
2.5.0

